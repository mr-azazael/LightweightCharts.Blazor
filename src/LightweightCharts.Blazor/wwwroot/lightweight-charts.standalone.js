/*!
 * @license
 * TradingView Lightweight Charts™ v5.0.3
 * Copyright (c) 2025 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
!function () { "use strict"; const t = { title: "", visible: !0, lastValueVisible: !0, priceLineVisible: !0, priceLineSource: 0, priceLineWidth: 1, priceLineColor: "", priceLineStyle: 2, baseLineVisible: !0, baseLineWidth: 1, baseLineColor: "#B2B5BE", baseLineStyle: 0, priceFormat: { type: "price", precision: 2, minMove: .01 } }; var i, n; function s(t, i) { const n = { 0: [], 1: [t.lineWidth, t.lineWidth], 2: [2 * t.lineWidth, 2 * t.lineWidth], 3: [6 * t.lineWidth, 6 * t.lineWidth], 4: [t.lineWidth, 4 * t.lineWidth] }[i]; t.setLineDash(n) } function e(t, i, n, s) { t.beginPath(); const e = t.lineWidth % 2 ? .5 : 0; t.moveTo(n, i + e), t.lineTo(s, i + e), t.stroke() } function r(t, i) { if (!t) throw new Error("Assertion failed" + (i ? ": " + i : "")) } function h(t) { if (void 0 === t) throw new Error("Value is undefined"); return t } function a(t) { if (null === t) throw new Error("Value is null"); return t } function l(t) { return a(h(t)) } !function (t) { t[t.Simple = 0] = "Simple", t[t.WithSteps = 1] = "WithSteps", t[t.Curved = 2] = "Curved" }(i || (i = {})), function (t) { t[t.Solid = 0] = "Solid", t[t.Dotted = 1] = "Dotted", t[t.Dashed = 2] = "Dashed", t[t.LargeDashed = 3] = "LargeDashed", t[t.SparseDotted = 4] = "SparseDotted" }(n || (n = {})); class o { constructor() { this.t = [] } i(t, i, n) { const s = { h: t, l: i, o: !0 === n }; this.t.push(s) } _(t) { const i = this.t.findIndex((i => t === i.h)); i > -1 && this.t.splice(i, 1) } u(t) { this.t = this.t.filter((i => i.l !== t)) } p(t, i, n) { const s = [...this.t]; this.t = this.t.filter((t => !t.o)), s.forEach((s => s.h(t, i, n))) } v() { return this.t.length > 0 } m() { this.t = [] } } function _(t, ...i) { for (const n of i) for (const i in n) void 0 !== n[i] && Object.prototype.hasOwnProperty.call(n, i) && !["__proto__", "constructor", "prototype"].includes(i) && ("object" != typeof n[i] || void 0 === t[i] || Array.isArray(n[i]) ? t[i] = n[i] : _(t[i], n[i])); return t } function u(t) { return "number" == typeof t && isFinite(t) } function c(t) { return "number" == typeof t && t % 1 == 0 } function d(t) { return "string" == typeof t } function f(t) { return "boolean" == typeof t } function p(t) { const i = t; if (!i || "object" != typeof i) return i; let n, s, e; for (s in n = Array.isArray(i) ? [] : {}, i) i.hasOwnProperty(s) && (e = i[s], n[s] = e && "object" == typeof e ? p(e) : e); return n } function v(t) { return null !== t } function m(t) { return null === t ? void 0 : t } const w = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif"; function g(t, i, n) { return void 0 === i && (i = w), `${n = void 0 !== n ? `${n} ` : ""}${t}px ${i}` } class M { constructor(t) { this.M = { S: 1, C: 5, k: NaN, P: "", T: "", R: "", D: "", I: 0, V: 0, A: 0, B: 0, O: 0 }, this.L = t } N() { const t = this.M, i = this.W(), n = this.F(); return t.k === i && t.T === n || (t.k = i, t.T = n, t.P = g(i, n), t.B = 2.5 / 12 * i, t.I = t.B, t.V = i / 12 * t.C, t.A = i / 12 * t.C, t.O = 0), t.R = this.H(), t.D = this.U(), this.M } H() { return this.L.N().layout.textColor } U() { return this.L.$() } W() { return this.L.N().layout.fontSize } F() { return this.L.N().layout.fontFamily } } function b(t) { return t < 0 ? 0 : t > 255 ? 255 : Math.round(t) || 0 } function x(t) { return .199 * t[0] + .687 * t[1] + .114 * t[2] } class S { constructor(t, i) { this.j = new Map, this.q = t, i && (this.j = i) } Y(t, i) { if ("transparent" === t) return t; const n = this.Z(t), s = n[3]; return `rgba(${n[0]}, ${n[1]}, ${n[2]}, ${i * s})` } K(t) { const i = this.Z(t); return { X: `rgb(${i[0]}, ${i[1]}, ${i[2]})`, G: x(i) > 160 ? "black" : "white" } } J(t) { return x(this.Z(t)) } tt(t, i, n) { const [s, e, r, h] = this.Z(t), [a, l, o, _] = this.Z(i), u = [b(s + n * (a - s)), b(e + n * (l - e)), b(r + n * (o - r)), (c = h + n * (_ - h), c <= 0 || c > 1 ? Math.min(Math.max(c, 0), 1) : Math.round(1e4 * c) / 1e4)]; var c; return `rgba(${u[0]}, ${u[1]}, ${u[2]}, ${u[3]})` } Z(t) { const i = this.j.get(t); if (i) return i; const n = function (t) { const i = document.createElement("div"); i.style.display = "none", document.body.appendChild(i), i.style.color = t; const n = window.getComputedStyle(i).color; return document.body.removeChild(i), n }(t), s = n.match(/^rgba?\s*\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d+))?\)$/); if (!s) { if (this.q.length) for (const i of this.q) { const n = i(t); if (n) return this.j.set(t, n), n } throw new Error(`Failed to parse color: ${t}`) } const e = [parseInt(s[1], 10), parseInt(s[2], 10), parseInt(s[3], 10), s[4] ? parseFloat(s[4]) : 1]; return this.j.set(t, e), e } } class C { constructor() { this.it = [] } nt(t) { this.it = t } st(t, i, n) { this.it.forEach((s => { s.st(t, i, n) })) } } class y { st(t, i, n) { t.useBitmapCoordinateSpace((t => this.et(t, i, n))) } } class k extends y { constructor() { super(...arguments), this.rt = null } ht(t) { this.rt = t } et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: n }) { if (null === this.rt || null === this.rt.lt) return; const s = this.rt.lt, e = this.rt, r = Math.max(1, Math.floor(i)) % 2 / 2, h = h => { t.beginPath(); for (let a = s.to - 1; a >= s.from; --a) { const s = e.ot[a], l = Math.round(s._t * i) + r, o = s.ut * n, _ = h * n + r; t.moveTo(l, o), t.arc(l, o, _, 0, 2 * Math.PI) } t.fill() }; e.ct > 0 && (t.fillStyle = e.dt, h(e.ft + e.ct)), t.fillStyle = e.vt, h(e.ft) } } function P() { return { ot: [{ _t: 0, ut: 0, wt: 0, gt: 0 }], vt: "", dt: "", ft: 0, ct: 0, lt: null } } const T = { from: 0, to: 1 }; class R { constructor(t, i, n) { this.Mt = new C, this.bt = [], this.xt = [], this.St = !0, this.L = t, this.Ct = i, this.yt = n, this.Mt.nt(this.bt) } kt(t) { this.Pt(), this.St = !0 } Tt() { return this.St && (this.Rt(), this.St = !1), this.Mt } Pt() { const t = this.yt.Dt(); t.length !== this.bt.length && (this.xt = t.map(P), this.bt = this.xt.map((t => { const i = new k; return i.ht(t), i })), this.Mt.nt(this.bt)) } Rt() { const t = 2 === this.Ct.N().mode || !this.Ct.Et(), i = this.yt.It(), n = this.Ct.Vt(), s = this.L.At(); this.Pt(), i.forEach(((i, e) => { const r = this.xt[e], h = i.Bt(n), a = i.zt(); !t && null !== h && i.Et() && null !== a ? (r.vt = h.Ot, r.ft = h.ft, r.ct = h.Lt, r.ot[0].gt = h.gt, r.ot[0].ut = i.Wt().Nt(h.gt, a.Ft), r.dt = h.Ht ?? this.L.Ut(r.ot[0].ut / i.Wt().$t()), r.ot[0].wt = n, r.ot[0]._t = s.jt(n), r.lt = T) : r.lt = null })) } } class D extends y { constructor(t) { super(), this.qt = t } et({ context: t, bitmapSize: i, horizontalPixelRatio: n, verticalPixelRatio: r }) { if (null === this.qt) return; const h = this.qt.Yt.Et, a = this.qt.Zt.Et; if (!h && !a) return; const l = Math.round(this.qt._t * n), o = Math.round(this.qt.ut * r); t.lineCap = "butt", h && l >= 0 && (t.lineWidth = Math.floor(this.qt.Yt.ct * n), t.strokeStyle = this.qt.Yt.R, t.fillStyle = this.qt.Yt.R, s(t, this.qt.Yt.Kt), function (t, i, n, s) { t.beginPath(); const e = t.lineWidth % 2 ? .5 : 0; t.moveTo(i + e, n), t.lineTo(i + e, s), t.stroke() }(t, l, 0, i.height)), a && o >= 0 && (t.lineWidth = Math.floor(this.qt.Zt.ct * r), t.strokeStyle = this.qt.Zt.R, t.fillStyle = this.qt.Zt.R, s(t, this.qt.Zt.Kt), e(t, o, 0, i.width)) } } class E { constructor(t, i) { this.St = !0, this.Xt = { Yt: { ct: 1, Kt: 0, R: "", Et: !1 }, Zt: { ct: 1, Kt: 0, R: "", Et: !1 }, _t: 0, ut: 0 }, this.Gt = new D(this.Xt), this.Jt = t, this.yt = i } kt() { this.St = !0 } Tt(t) { return this.St && (this.Rt(), this.St = !1), this.Gt } Rt() { const t = this.Jt.Et(), i = this.yt.Qt().N().crosshair, n = this.Xt; if (2 === i.mode) return n.Zt.Et = !1, void (n.Yt.Et = !1); n.Zt.Et = t && this.Jt.ti(this.yt), n.Yt.Et = t && this.Jt.ii(), n.Zt.ct = i.horzLine.width, n.Zt.Kt = i.horzLine.style, n.Zt.R = i.horzLine.color, n.Yt.ct = i.vertLine.width, n.Yt.Kt = i.vertLine.style, n.Yt.R = i.vertLine.color, n._t = this.Jt.ni(), n.ut = this.Jt.si() } } function I(t, i, n, s, e, r) { t.fillRect(i + r, n, s - 2 * r, r), t.fillRect(i + r, n + e - r, s - 2 * r, r), t.fillRect(i, n, r, e), t.fillRect(i + s - r, n, r, e) } function V(t, i, n, s, e, r) { t.save(), t.globalCompositeOperation = "copy", t.fillStyle = r, t.fillRect(i, n, s, e), t.restore() } function A(t, i, n, s, e, r) { t.beginPath(), t.roundRect ? t.roundRect(i, n, s, e, r) : (t.lineTo(i + s - r[1], n), 0 !== r[1] && t.arcTo(i + s, n, i + s, n + r[1], r[1]), t.lineTo(i + s, n + e - r[2]), 0 !== r[2] && t.arcTo(i + s, n + e, i + s - r[2], n + e, r[2]), t.lineTo(i + r[3], n + e), 0 !== r[3] && t.arcTo(i, n + e, i, n + e - r[3], r[3]), t.lineTo(i, n + r[0]), 0 !== r[0] && t.arcTo(i, n, i + r[0], n, r[0])) } function B(t, i, n, s, e, r, h = 0, a = [0, 0, 0, 0], l = "") { if (t.save(), !h || !l || l === r) return A(t, i, n, s, e, a), t.fillStyle = r, t.fill(), void t.restore(); const o = h / 2; var _; A(t, i + o, n + o, s - h, e - h, (_ = -o, a.map((t => 0 === t ? t : t + _)))), "transparent" !== r && (t.fillStyle = r, t.fill()), "transparent" !== l && (t.lineWidth = h, t.strokeStyle = l, t.closePath(), t.stroke()), t.restore() } function z(t, i, n, s, e, r, h) { t.save(), t.globalCompositeOperation = "copy"; const a = t.createLinearGradient(0, 0, 0, e); a.addColorStop(0, r), a.addColorStop(1, h), t.fillStyle = a, t.fillRect(i, n, s, e), t.restore() } class O { constructor(t, i) { this.ht(t, i) } ht(t, i) { this.qt = t, this.ei = i } $t(t, i) { return this.qt.Et ? t.k + t.B + t.I : 0 } st(t, i, n, s) { if (!this.qt.Et || 0 === this.qt.ri.length) return; const e = this.qt.R, r = this.ei.X, h = t.useBitmapCoordinateSpace((t => { const h = t.context; h.font = i.P; const a = this.hi(t, i, n, s), l = a.ai; return a.li ? B(h, l.oi, l._i, l.ui, l.ci, r, l.di, [l.ft, 0, 0, l.ft], r) : B(h, l.fi, l._i, l.ui, l.ci, r, l.di, [0, l.ft, l.ft, 0], r), this.qt.pi && (h.fillStyle = e, h.fillRect(l.fi, l.mi, l.wi - l.fi, l.gi)), this.qt.Mi && (h.fillStyle = i.D, h.fillRect(a.li ? l.bi - l.di : 0, l._i, l.di, l.xi - l._i)), a })); t.useMediaCoordinateSpace((({ context: t }) => { const n = h.Si; t.font = i.P, t.textAlign = h.li ? "right" : "left", t.textBaseline = "middle", t.fillStyle = e, t.fillText(this.qt.ri, n.Ci, (n._i + n.xi) / 2 + n.yi) })) } hi(t, i, n, s) { const { context: e, bitmapSize: r, mediaSize: h, horizontalPixelRatio: a, verticalPixelRatio: l } = t, o = this.qt.pi || !this.qt.ki ? i.C : 0, _ = this.qt.Pi ? i.S : 0, u = i.B + this.ei.Ti, c = i.I + this.ei.Ri, d = i.V, f = i.A, p = this.qt.ri, v = i.k, m = n.Di(e, p), w = Math.ceil(n.Ei(e, p)), g = v + u + c, M = i.S + d + f + w + o, b = Math.max(1, Math.floor(l)); let x = Math.round(g * l); x % 2 != b % 2 && (x += 1); const S = _ > 0 ? Math.max(1, Math.floor(_ * a)) : 0, C = Math.round(M * a), y = Math.round(o * a), k = this.ei.Ii ?? this.ei.Vi, P = Math.round(k * l) - Math.floor(.5 * l), T = Math.floor(P + b / 2 - x / 2), R = T + x, D = "right" === s, E = D ? h.width - _ : _, I = D ? r.width - S : S; let V, A, B; return D ? (V = I - C, A = I - y, B = E - o - d - _) : (V = I + C, A = I + y, B = E + o + d), { li: D, ai: { _i: T, mi: P, xi: R, ui: C, ci: x, ft: 2 * a, di: S, oi: V, fi: I, wi: A, gi: b, bi: r.width }, Si: { _i: T / l, xi: R / l, Ci: B, yi: m } } } } class L { constructor(t) { this.Ai = { Vi: 0, X: "#000", Ri: 0, Ti: 0 }, this.Bi = { ri: "", Et: !1, pi: !0, ki: !1, Ht: "", R: "#FFF", Mi: !1, Pi: !1 }, this.zi = { ri: "", Et: !1, pi: !1, ki: !0, Ht: "", R: "#FFF", Mi: !0, Pi: !0 }, this.St = !0, this.Oi = new (t || O)(this.Bi, this.Ai), this.Li = new (t || O)(this.zi, this.Ai) } ri() { return this.Ni(), this.Bi.ri } Vi() { return this.Ni(), this.Ai.Vi } kt() { this.St = !0 } $t(t, i = !1) { return Math.max(this.Oi.$t(t, i), this.Li.$t(t, i)) } Wi() { return this.Ai.Ii || 0 } Fi(t) { this.Ai.Ii = t } Hi() { return this.Ni(), this.Bi.Et || this.zi.Et } Ui() { return this.Ni(), this.Bi.Et } Tt(t) { return this.Ni(), this.Bi.pi = this.Bi.pi && t.N().ticksVisible, this.zi.pi = this.zi.pi && t.N().ticksVisible, this.Oi.ht(this.Bi, this.Ai), this.Li.ht(this.zi, this.Ai), this.Oi } $i() { return this.Ni(), this.Oi.ht(this.Bi, this.Ai), this.Li.ht(this.zi, this.Ai), this.Li } Ni() { this.St && (this.Bi.pi = !0, this.zi.pi = !1, this.ji(this.Bi, this.zi, this.Ai)) } } class N extends L { constructor(t, i, n) { super(), this.Jt = t, this.qi = i, this.Yi = n } ji(t, i, n) { if (t.Et = !1, 2 === this.Jt.N().mode) return; const s = this.Jt.N().horzLine; if (!s.labelVisible) return; const e = this.qi.zt(); if (!this.Jt.Et() || this.qi.Zi() || null === e) return; const r = this.qi.Ki().K(s.labelBackgroundColor); n.X = r.X, t.R = r.G; const h = 2 / 12 * this.qi.k(); n.Ti = h, n.Ri = h; const a = this.Yi(this.qi); n.Vi = a.Vi, t.ri = this.qi.Xi(a.gt, e), t.Et = !0 } } const W = /[1-9]/g; class F { constructor() { this.qt = null } ht(t) { this.qt = t } st(t, i) { if (null === this.qt || !1 === this.qt.Et || 0 === this.qt.ri.length) return; const n = t.useMediaCoordinateSpace((({ context: t }) => (t.font = i.P, Math.round(i.Gi.Ei(t, a(this.qt).ri, W))))); if (n <= 0) return; const s = i.Ji, e = n + 2 * s, r = e / 2, h = this.qt.Qi; let l = this.qt.Vi, o = Math.floor(l - r) + .5; o < 0 ? (l += Math.abs(0 - o), o = Math.floor(l - r) + .5) : o + e > h && (l -= Math.abs(h - (o + e)), o = Math.floor(l - r) + .5); const _ = o + e, u = Math.ceil(0 + i.S + i.C + i.B + i.k + i.I); t.useBitmapCoordinateSpace((({ context: t, horizontalPixelRatio: n, verticalPixelRatio: s }) => { const e = a(this.qt); t.fillStyle = e.X; const r = Math.round(o * n), h = Math.round(0 * s), l = Math.round(_ * n), c = Math.round(u * s), d = Math.round(2 * n); if (t.beginPath(), t.moveTo(r, h), t.lineTo(r, c - d), t.arcTo(r, c, r + d, c, d), t.lineTo(l - d, c), t.arcTo(l, c, l, c - d, d), t.lineTo(l, h), t.fill(), e.pi) { const r = Math.round(e.Vi * n), a = h, l = Math.round((a + i.C) * s); t.fillStyle = e.R; const o = Math.max(1, Math.floor(n)), _ = Math.floor(.5 * n); t.fillRect(r - _, a, o, l - a) } })), t.useMediaCoordinateSpace((({ context: t }) => { const n = a(this.qt), e = 0 + i.S + i.C + i.B + i.k / 2; t.font = i.P, t.textAlign = "left", t.textBaseline = "middle", t.fillStyle = n.R; const r = i.Gi.Di(t, "Apr0"); t.translate(o + s, e + r), t.fillText(n.ri, 0, 0) })) } } class H { constructor(t, i, n) { this.St = !0, this.Gt = new F, this.Xt = { Et: !1, X: "#4c525e", R: "white", ri: "", Qi: 0, Vi: NaN, pi: !0 }, this.Ct = t, this.tn = i, this.Yi = n } kt() { this.St = !0 } Tt() { return this.St && (this.Rt(), this.St = !1), this.Gt.ht(this.Xt), this.Gt } Rt() { const t = this.Xt; if (t.Et = !1, 2 === this.Ct.N().mode) return; const i = this.Ct.N().vertLine; if (!i.labelVisible) return; const n = this.tn.At(); if (n.Zi()) return; t.Qi = n.Qi(); const s = this.Yi(); if (null === s) return; t.Vi = s.Vi; const e = n.nn(this.Ct.Vt()); t.ri = n.sn(a(e)), t.Et = !0; const r = this.tn.Ki().K(i.labelBackgroundColor); t.X = r.X, t.R = r.G, t.pi = n.N().ticksVisible } } class U { constructor() { this.en = null, this.rn = 0 } hn() { return this.rn } an(t) { this.rn = t } Wt() { return this.en } ln(t) { this.en = t } _n(t) { return [] } un() { return [] } Et() { return !0 } } var $; !function (t) { t[t.Normal = 0] = "Normal", t[t.Magnet = 1] = "Magnet", t[t.Hidden = 2] = "Hidden" }($ || ($ = {})); class j extends U { constructor(t, i) { super(), this.yt = null, this.cn = NaN, this.dn = 0, this.fn = !0, this.pn = new Map, this.vn = !1, this.mn = new WeakMap, this.wn = new WeakMap, this.gn = NaN, this.Mn = NaN, this.bn = NaN, this.xn = NaN, this.tn = t, this.Sn = i; this.Cn = ((t, i) => n => { const s = i(), e = t(); if (n === a(this.yt).yn()) return { gt: e, Vi: s }; { const t = a(n.zt()); return { gt: n.kn(s, t), Vi: s } } })((() => this.cn), (() => this.Mn)); const n = ((t, i) => () => { const n = this.tn.At().Pn(t()), s = i(); return n && Number.isFinite(s) ? { wt: n, Vi: s } : null })((() => this.dn), (() => this.ni())); this.Tn = new H(this, t, n) } N() { return this.Sn } Rn(t, i) { this.bn = t, this.xn = i } Dn() { this.bn = NaN, this.xn = NaN } En() { return this.bn } In() { return this.xn } Vn(t, i, n) { this.vn || (this.vn = !0), this.fn = !0, this.An(t, i, n) } Vt() { return this.dn } ni() { return this.gn } si() { return this.Mn } Et() { return this.fn } Bn() { this.fn = !1, this.zn(), this.cn = NaN, this.gn = NaN, this.Mn = NaN, this.yt = null, this.Dn(), this.On() } Ln(t) { let i = this.mn.get(t); i || (i = new E(this, t), this.mn.set(t, i)); let n = this.wn.get(t); return n || (n = new R(this.tn, this, t), this.wn.set(t, n)), [i, n] } ti(t) { return t === this.yt && this.Sn.horzLine.visible } ii() { return this.Sn.vertLine.visible } Nn(t, i) { this.fn && this.yt === t || this.pn.clear(); const n = []; return this.yt === t && n.push(this.Wn(this.pn, i, this.Cn)), n } un() { return this.fn ? [this.Tn] : [] } Fn() { return this.yt } On() { this.tn.Hn().forEach((t => { this.mn.get(t)?.kt(), this.wn.get(t)?.kt() })), this.pn.forEach((t => t.kt())), this.Tn.kt() } Un(t) { return t && !t.yn().Zi() ? t.yn() : null } An(t, i, n) { this.$n(t, i, n) && this.On() } $n(t, i, n) { const s = this.gn, e = this.Mn, r = this.cn, h = this.dn, a = this.yt, l = this.Un(n); this.dn = t, this.gn = isNaN(t) ? NaN : this.tn.At().jt(t), this.yt = n; const o = null !== l ? l.zt() : null; return null !== l && null !== o ? (this.cn = i, this.Mn = l.Nt(i, o)) : (this.cn = NaN, this.Mn = NaN), s !== this.gn || e !== this.Mn || h !== this.dn || r !== this.cn || a !== this.yt } zn() { const t = this.tn.jn().map((t => t.Yn().qn())).filter(v), i = 0 === t.length ? null : Math.max(...t); this.dn = null !== i ? i : NaN } Wn(t, i, n) { let s = t.get(i); return void 0 === s && (s = new N(this, i, n), t.set(i, s)), s } } function q(t) { return "left" === t || "right" === t } class Y { constructor(t) { this.Zn = new Map, this.Kn = [], this.Xn = t } Gn(t, i) { const n = function (t, i) { return void 0 === t ? i : { Jn: Math.max(t.Jn, i.Jn), Qn: t.Qn || i.Qn } }(this.Zn.get(t), i); this.Zn.set(t, n) } ts() { return this.Xn } ns(t) { const i = this.Zn.get(t); return void 0 === i ? { Jn: this.Xn } : { Jn: Math.max(this.Xn, i.Jn), Qn: i.Qn } } ss() { this.es(), this.Kn = [{ rs: 0 }] } hs(t) { this.es(), this.Kn = [{ rs: 1, Ft: t }] } ls(t) { this._s(), this.Kn.push({ rs: 5, Ft: t }) } es() { this._s(), this.Kn.push({ rs: 6 }) } us() { this.es(), this.Kn = [{ rs: 4 }] } cs(t) { this.es(), this.Kn.push({ rs: 2, Ft: t }) } ds(t) { this.es(), this.Kn.push({ rs: 3, Ft: t }) } fs() { return this.Kn } ps(t) { for (const i of t.Kn) this.vs(i); this.Xn = Math.max(this.Xn, t.Xn), t.Zn.forEach(((t, i) => { this.Gn(i, t) })) } static ws() { return new Y(2) } static gs() { return new Y(3) } vs(t) { switch (t.rs) { case 0: this.ss(); break; case 1: this.hs(t.Ft); break; case 2: this.cs(t.Ft); break; case 3: this.ds(t.Ft); break; case 4: this.us(); break; case 5: this.ls(t.Ft); break; case 6: this._s() } } _s() { const t = this.Kn.findIndex((t => 5 === t.rs)); -1 !== t && this.Kn.splice(t, 1) } } const Z = "."; function K(t, i) { if (!u(t)) return "n/a"; if (!c(i)) throw new TypeError("invalid length"); if (i < 0 || i > 16) throw new TypeError("invalid length"); if (0 === i) return t.toString(); return ("0000000000000000" + t.toString()).slice(-i) } class X { constructor(t, i) { if (i || (i = 1), u(t) && c(t) || (t = 100), t < 0) throw new TypeError("invalid base"); this.qi = t, this.Ms = i, this.bs() } format(t) { const i = t < 0 ? "−" : ""; return t = Math.abs(t), i + this.xs(t) } bs() { if (this.Ss = 0, this.qi > 0 && this.Ms > 0) { let t = this.qi; for (; t > 1;)t /= 10, this.Ss++ } } xs(t) { const i = this.qi / this.Ms; let n = Math.floor(t), s = ""; const e = void 0 !== this.Ss ? this.Ss : NaN; if (i > 1) { let r = +(Math.round(t * i) - n * i).toFixed(this.Ss); r >= i && (r -= i, n += 1), s = Z + K(+r.toFixed(this.Ss) * this.Ms, e) } else n = Math.round(n * i) / i, e > 0 && (s = Z + K(0, e)); return n.toFixed(0) + s } } class G extends X { constructor(t = 100) { super(t) } format(t) { return `${super.format(t)}%` } } class J { constructor(t) { this.Cs = t } format(t) { let i = ""; return t < 0 && (i = "-", t = -t), t < 995 ? i + this.ys(t) : t < 999995 ? i + this.ys(t / 1e3) + "K" : t < 999999995 ? (t = 1e3 * Math.round(t / 1e3), i + this.ys(t / 1e6) + "M") : (t = 1e6 * Math.round(t / 1e6), i + this.ys(t / 1e9) + "B") } ys(t) { let i; const n = Math.pow(10, this.Cs); return i = (t = Math.round(t * n) / n) >= 1e-15 && t < 1 ? t.toFixed(this.Cs).replace(/\.?0+$/, "") : String(t), i.replace(/(\.[1-9]*)0+$/, ((t, i) => i)) } } const Q = /[2-9]/g; class tt { constructor(t = 50) { this.ks = 0, this.Ps = 1, this.Ts = 1, this.Rs = {}, this.Ds = new Map, this.Es = t } Is() { this.ks = 0, this.Ds.clear(), this.Ps = 1, this.Ts = 1, this.Rs = {} } Ei(t, i, n) { return this.Vs(t, i, n).width } Di(t, i, n) { const s = this.Vs(t, i, n); return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2 } Vs(t, i, n) { const s = n || Q, e = String(i).replace(s, "0"); if (this.Ds.has(e)) return h(this.Ds.get(e)).As; if (this.ks === this.Es) { const t = this.Rs[this.Ts]; delete this.Rs[this.Ts], this.Ds.delete(t), this.Ts++, this.ks-- } t.save(), t.textBaseline = "middle"; const r = t.measureText(e); return t.restore(), 0 === r.width && i.length || (this.Ds.set(e, { As: r, Bs: this.Ps }), this.Rs[this.Ps] = e, this.ks++, this.Ps++), r } } class it { constructor(t) { this.zs = null, this.M = null, this.Os = "right", this.Ls = t } Ns(t, i, n) { this.zs = t, this.M = i, this.Os = n } st(t) { null !== this.M && null !== this.zs && this.zs.st(t, this.M, this.Ls, this.Os) } } class nt { constructor(t, i, n) { this.Ws = t, this.Ls = new tt(50), this.Fs = i, this.L = n, this.W = -1, this.Gt = new it(this.Ls) } Tt() { const t = this.L.Hs(this.Fs); if (null === t) return null; const i = t.Us(this.Fs) ? t.$s() : this.Fs.Wt(); if (null === i) return null; const n = t.js(i); if ("overlay" === n) return null; const s = this.L.qs(); return s.k !== this.W && (this.W = s.k, this.Ls.Is()), this.Gt.Ns(this.Ws.$i(), s, n), this.Gt } } class st extends y { constructor() { super(...arguments), this.qt = null } ht(t) { this.qt = t } Ys(t, i) { if (!this.qt?.Et) return null; const { ut: n, ct: s, Zs: e } = this.qt; return i >= n - s - 7 && i <= n + s + 7 ? { Ks: this.qt, Zs: e } : null } et({ context: t, bitmapSize: i, horizontalPixelRatio: n, verticalPixelRatio: r }) { if (null === this.qt) return; if (!1 === this.qt.Et) return; const h = Math.round(this.qt.ut * r); h < 0 || h > i.height || (t.lineCap = "butt", t.strokeStyle = this.qt.R, t.lineWidth = Math.floor(this.qt.ct * n), s(t, this.qt.Kt), e(t, h, 0, i.width)) } } class et { constructor(t) { this.Xs = { ut: 0, R: "rgba(0, 0, 0, 0)", ct: 1, Kt: 0, Et: !1 }, this.Gs = new st, this.St = !0, this.Js = t, this.Qs = t.Qt(), this.Gs.ht(this.Xs) } kt() { this.St = !0 } Tt() { return this.Js.Et() ? (this.St && (this.te(), this.St = !1), this.Gs) : null } } class rt extends et { constructor(t) { super(t) } te() { this.Xs.Et = !1; const t = this.Js.Wt(), i = t.ie().ie; if (2 !== i && 3 !== i) return; const n = this.Js.N(); if (!n.baseLineVisible || !this.Js.Et()) return; const s = this.Js.zt(); null !== s && (this.Xs.Et = !0, this.Xs.ut = t.Nt(s.Ft, s.Ft), this.Xs.R = n.baseLineColor, this.Xs.ct = n.baseLineWidth, this.Xs.Kt = n.baseLineStyle) } } class ht extends y { constructor() { super(...arguments), this.qt = null } ht(t) { this.qt = t } ne() { return this.qt } et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: n }) { const s = this.qt; if (null === s) return; const e = Math.max(1, Math.floor(i)), r = e % 2 / 2, h = Math.round(s.se.x * i) + r, a = s.se.y * n; t.fillStyle = s.ee, t.beginPath(); const l = Math.max(2, 1.5 * s.re) * i; t.arc(h, a, l, 0, 2 * Math.PI, !1), t.fill(), t.fillStyle = s.he, t.beginPath(), t.arc(h, a, s.ft * i, 0, 2 * Math.PI, !1), t.fill(), t.lineWidth = e, t.strokeStyle = s.ae, t.beginPath(), t.arc(h, a, s.ft * i + e / 2, 0, 2 * Math.PI, !1), t.stroke() } } const at = [{ le: 0, oe: .25, _e: 4, ue: 10, ce: .25, de: 0, fe: .4, pe: .8 }, { le: .25, oe: .525, _e: 10, ue: 14, ce: 0, de: 0, fe: .8, pe: 0 }, { le: .525, oe: 1, _e: 14, ue: 14, ce: 0, de: 0, fe: 0, pe: 0 }]; class lt { constructor(t) { this.Gt = new ht, this.St = !0, this.ve = !0, this.me = performance.now(), this.we = this.me - 1, this.ge = t } Me() { this.we = this.me - 1, this.kt() } be() { if (this.kt(), 2 === this.ge.N().lastPriceAnimation) { const t = performance.now(), i = this.we - t; if (i > 0) return void (i < 650 && (this.we += 2600)); this.me = t, this.we = t + 2600 } } kt() { this.St = !0 } xe() { this.ve = !0 } Et() { return 0 !== this.ge.N().lastPriceAnimation } Se() { switch (this.ge.N().lastPriceAnimation) { case 0: return !1; case 1: return !0; case 2: return performance.now() <= this.we } } Tt() { return this.St ? (this.Rt(), this.St = !1, this.ve = !1) : this.ve && (this.Ce(), this.ve = !1), this.Gt } Rt() { this.Gt.ht(null); const t = this.ge.Qt().At(), i = t.ye(), n = this.ge.zt(); if (null === i || null === n) return; const s = this.ge.ke(!0); if (s.Pe || !i.Te(s.Re)) return; const e = { x: t.jt(s.Re), y: this.ge.Wt().Nt(s.gt, n.Ft) }, r = s.R, h = this.ge.N().lineWidth, a = this.De(this.Ee(), r); this.Gt.ht({ ee: r, re: h, he: a.he, ae: a.ae, ft: a.ft, se: e }) } Ce() { const t = this.Gt.ne(); if (null !== t) { const i = this.De(this.Ee(), t.ee); t.he = i.he, t.ae = i.ae, t.ft = i.ft } } Ee() { return this.Se() ? performance.now() - this.me : 2599 } Ie(t, i, n, s) { const e = n + (s - n) * i; return this.ge.Qt().Ki().Y(t, e) } De(t, i) { const n = t % 2600 / 2600; let s; for (const t of at) if (n >= t.le && n <= t.oe) { s = t; break } r(void 0 !== s, "Last price animation internal logic error"); const e = (n - s.le) / (s.oe - s.le); return { he: this.Ie(i, e, s.ce, s.de), ae: this.Ie(i, e, s.fe, s.pe), ft: (h = e, a = s._e, l = s.ue, a + (l - a) * h) }; var h, a, l } } class ot extends et { constructor(t) { super(t) } te() { const t = this.Xs; t.Et = !1; const i = this.Js.N(); if (!i.priceLineVisible || !this.Js.Et()) return; const n = this.Js.ke(0 === i.priceLineSource); n.Pe || (t.Et = !0, t.ut = n.Vi, t.R = this.Js.Ve(n.R), t.ct = i.priceLineWidth, t.Kt = i.priceLineStyle) } } class _t extends L { constructor(t) { super(), this.Jt = t } ji(t, i, n) { t.Et = !1, i.Et = !1; const s = this.Jt; if (!s.Et()) return; const e = s.N(), r = e.lastValueVisible, h = "" !== s.Ae(), a = 0 === e.seriesLastValueMode, l = s.ke(!1); if (l.Pe) return; r && (t.ri = this.Be(l, r, a), t.Et = 0 !== t.ri.length), (h || a) && (i.ri = this.ze(l, r, h, a), i.Et = i.ri.length > 0); const o = s.Ve(l.R), _ = this.Jt.Qt().Ki().K(o); n.X = _.X, n.Vi = l.Vi, i.Ht = s.Qt().Ut(l.Vi / s.Wt().$t()), t.Ht = o, t.R = _.G, i.R = _.G } ze(t, i, n, s) { let e = ""; const r = this.Jt.Ae(); return n && 0 !== r.length && (e += `${r} `), i && s && (e += this.Jt.Wt().Oe() ? t.Le : t.Ne), e.trim() } Be(t, i, n) { return i ? n ? this.Jt.Wt().Oe() ? t.Ne : t.Le : t.ri : "" } } function ut(t, i, n, s) { const e = Number.isFinite(i), r = Number.isFinite(n); return e && r ? t(i, n) : e || r ? e ? i : n : s } class ct { constructor(t, i) { this.We = t, this.Fe = i } He(t) { return null !== t && (this.We === t.We && this.Fe === t.Fe) } Ue() { return new ct(this.We, this.Fe) } $e() { return this.We } je() { return this.Fe } qe() { return this.Fe - this.We } Zi() { return this.Fe === this.We || Number.isNaN(this.Fe) || Number.isNaN(this.We) } ps(t) { return null === t ? this : new ct(ut(Math.min, this.$e(), t.$e(), -1 / 0), ut(Math.max, this.je(), t.je(), 1 / 0)) } Ye(t) { if (!u(t)) return; if (0 === this.Fe - this.We) return; const i = .5 * (this.Fe + this.We); let n = this.Fe - i, s = this.We - i; n *= t, s *= t, this.Fe = i + n, this.We = i + s } Ze(t) { u(t) && (this.Fe += t, this.We += t) } Ke() { return { minValue: this.We, maxValue: this.Fe } } static Xe(t) { return null === t ? null : new ct(t.minValue, t.maxValue) } } class dt { constructor(t, i) { this.Ge = t, this.Je = i || null } Qe() { return this.Ge } tr() { return this.Je } Ke() { return { priceRange: null === this.Ge ? null : this.Ge.Ke(), margins: this.Je || void 0 } } static Xe(t) { return null === t ? null : new dt(ct.Xe(t.priceRange), t.margins) } } class ft extends et { constructor(t, i) { super(t), this.ir = i } te() { const t = this.Xs; t.Et = !1; const i = this.ir.N(); if (!this.Js.Et() || !i.lineVisible) return; const n = this.ir.nr(); null !== n && (t.Et = !0, t.ut = n, t.R = i.color, t.ct = i.lineWidth, t.Kt = i.lineStyle, t.Zs = this.ir.N().id) } } class pt extends L { constructor(t, i) { super(), this.ge = t, this.ir = i } ji(t, i, n) { t.Et = !1, i.Et = !1; const s = this.ir.N(), e = s.axisLabelVisible, r = "" !== s.title, h = this.ge; if (!e || !h.Et()) return; const a = this.ir.nr(); if (null === a) return; r && (i.ri = s.title, i.Et = !0), i.Ht = h.Qt().Ut(a / h.Wt().$t()), t.ri = this.sr(s.price), t.Et = !0; const l = this.ge.Qt().Ki().K(s.axisLabelColor || s.color); n.X = l.X; const o = s.axisLabelTextColor || l.G; t.R = o, i.R = o, n.Vi = a } sr(t) { const i = this.ge.zt(); return null === i ? "" : this.ge.Wt().Xi(t, i.Ft) } } class vt { constructor(t, i) { this.ge = t, this.Sn = i, this.er = new ft(t, this), this.Ws = new pt(t, this), this.rr = new nt(this.Ws, t, t.Qt()) } hr(t) { _(this.Sn, t), this.kt(), this.ge.Qt().ar() } N() { return this.Sn } lr() { return this.er } _r() { return this.rr } ur() { return this.Ws } kt() { this.er.kt(), this.Ws.kt() } nr() { const t = this.ge, i = t.Wt(); if (t.Qt().At().Zi() || i.Zi()) return null; const n = t.zt(); return null === n ? null : i.Nt(this.Sn.price, n.Ft) } } class mt extends U { constructor(t) { super(), this.tn = t } Qt() { return this.tn } } const wt = { Bar: (t, i, n, s) => { const e = i.upColor, r = i.downColor, h = a(t(n, s)), o = l(h.Ft[0]) <= l(h.Ft[3]); return { cr: h.R ?? (o ? e : r) } }, Candlestick: (t, i, n, s) => { const e = i.upColor, r = i.downColor, h = i.borderUpColor, o = i.borderDownColor, _ = i.wickUpColor, u = i.wickDownColor, c = a(t(n, s)), d = l(c.Ft[0]) <= l(c.Ft[3]); return { cr: c.R ?? (d ? e : r), dr: c.Ht ?? (d ? h : o), pr: c.vr ?? (d ? _ : u) } }, Custom: (t, i, n, s) => ({ cr: a(t(n, s)).R ?? i.color }), Area: (t, i, n, s) => { const e = a(t(n, s)); return { cr: e.vt ?? i.lineColor, vt: e.vt ?? i.lineColor, mr: e.mr ?? i.topColor, wr: e.wr ?? i.bottomColor } }, Baseline: (t, i, n, s) => { const e = a(t(n, s)); return { cr: e.Ft[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor, gr: e.gr ?? i.topLineColor, Mr: e.Mr ?? i.bottomLineColor, br: e.br ?? i.topFillColor1, Sr: e.Sr ?? i.topFillColor2, Cr: e.Cr ?? i.bottomFillColor1, yr: e.yr ?? i.bottomFillColor2 } }, Line: (t, i, n, s) => { const e = a(t(n, s)); return { cr: e.R ?? i.color, vt: e.R ?? i.color } }, Histogram: (t, i, n, s) => ({ cr: a(t(n, s)).R ?? i.color }) }; class gt { constructor(t) { this.kr = (t, i) => void 0 !== i ? i.Ft : this.ge.Yn().Pr(t), this.ge = t, this.Tr = wt[t.Rr()] } Dr(t, i) { return this.Tr(this.kr, this.ge.N(), t, i) } } function Mt(t, i, n, s, e = 0, r = i.length) { let h = r - e; for (; 0 < h;) { const r = h >> 1, a = e + r; s(i[a], n) === t ? (e = a + 1, h -= r + 1) : h = r } return e } const bt = Mt.bind(null, !0), xt = Mt.bind(null, !1); var St; !function (t) { t[t.NearestLeft = -1] = "NearestLeft", t[t.None = 0] = "None", t[t.NearestRight = 1] = "NearestRight" }(St || (St = {})); const Ct = 30; class yt { constructor() { this.Er = [], this.Ir = new Map, this.Vr = new Map, this.Ar = [] } Br() { return this.zr() > 0 ? this.Er[this.Er.length - 1] : null } Or() { return this.zr() > 0 ? this.Lr(0) : null } qn() { return this.zr() > 0 ? this.Lr(this.Er.length - 1) : null } zr() { return this.Er.length } Zi() { return 0 === this.zr() } Te(t) { return null !== this.Nr(t, 0) } Pr(t) { return this.Wr(t) } Wr(t, i = 0) { const n = this.Nr(t, i); return null === n ? null : { ...this.Fr(n), Re: this.Lr(n) } } Hr() { return this.Er } Ur(t, i, n) { if (this.Zi()) return null; let s = null; for (const e of n) { s = kt(s, this.$r(t, i, e)) } return s } ht(t) { this.Vr.clear(), this.Ir.clear(), this.Er = t, this.Ar = t.map((t => t.Re)) } jr() { return this.Ar } Lr(t) { return this.Er[t].Re } Fr(t) { return this.Er[t] } Nr(t, i) { const n = this.qr(t); if (null === n && 0 !== i) switch (i) { case -1: return this.Yr(t); case 1: return this.Zr(t); default: throw new TypeError("Unknown search mode") }return n } Yr(t) { let i = this.Kr(t); return i > 0 && (i -= 1), i !== this.Er.length && this.Lr(i) < t ? i : null } Zr(t) { const i = this.Xr(t); return i !== this.Er.length && t < this.Lr(i) ? i : null } qr(t) { const i = this.Kr(t); return i === this.Er.length || t < this.Er[i].Re ? null : i } Kr(t) { return bt(this.Er, t, ((t, i) => t.Re < i)) } Xr(t) { return xt(this.Er, t, ((t, i) => t.Re > i)) } Gr(t, i, n) { let s = null; for (let e = t; e < i; e++) { const t = this.Er[e].Ft[n]; Number.isNaN(t) || (null === s ? s = { Jr: t, Qr: t } : (t < s.Jr && (s.Jr = t), t > s.Qr && (s.Qr = t))) } return s } $r(t, i, n) { if (this.Zi()) return null; let s = null; const e = a(this.Or()), r = a(this.qn()), h = Math.max(t, e), l = Math.min(i, r), o = Math.ceil(h / Ct) * Ct, _ = Math.max(o, Math.floor(l / Ct) * Ct); { const t = this.Kr(h), e = this.Xr(Math.min(l, o, i)); s = kt(s, this.Gr(t, e, n)) } let u = this.Ir.get(n); void 0 === u && (u = new Map, this.Ir.set(n, u)); for (let t = Math.max(o + 1, h); t < _; t += Ct) { const i = Math.floor(t / Ct); let e = u.get(i); if (void 0 === e) { const t = this.Kr(i * Ct), s = this.Xr((i + 1) * Ct - 1); e = this.Gr(t, s, n), u.set(i, e) } s = kt(s, e) } { const t = this.Kr(_), i = this.Xr(l); s = kt(s, this.Gr(t, i, n)) } return s } } function kt(t, i) { if (null === t) return i; if (null === i) return t; return { Jr: Math.min(t.Jr, i.Jr), Qr: Math.max(t.Qr, i.Qr) } } class Pt { constructor(t) { this.th = t } st(t, i, n) { this.th.draw(t) } ih(t, i, n) { this.th.drawBackground?.(t) } } class Tt { constructor(t) { this.Ds = null, this.nh = t } Tt() { const t = this.nh.renderer(); if (null === t) return null; if (this.Ds?.sh === t) return this.Ds.eh; const i = new Pt(t); return this.Ds = { sh: t, eh: i }, i } rh() { return this.nh.zOrder?.() ?? "normal" } } class Rt { constructor(t) { this.hh = null, this.ah = t } oh() { return this.ah } On() { this.ah.updateAllViews?.() } Ln() { const t = this.ah.paneViews?.() ?? []; if (this.hh?.sh === t) return this.hh.eh; const i = t.map((t => new Tt(t))); return this.hh = { sh: t, eh: i }, i } Ys(t, i) { return this.ah.hitTest?.(t, i) ?? null } } let Dt = class extends Rt { _n() { return [] } }; class Et { constructor(t) { this.th = t } st(t, i, n) { this.th.draw(t) } ih(t, i, n) { this.th.drawBackground?.(t) } } class It { constructor(t) { this.Ds = null, this.nh = t } Tt() { const t = this.nh.renderer(); if (null === t) return null; if (this.Ds?.sh === t) return this.Ds.eh; const i = new Et(t); return this.Ds = { sh: t, eh: i }, i } rh() { return this.nh.zOrder?.() ?? "normal" } } function Vt(t) { return { ri: t.text(), Vi: t.coordinate(), Ii: t.fixedCoordinate?.(), R: t.textColor(), X: t.backColor(), Et: t.visible?.() ?? !0, pi: t.tickVisible?.() ?? !0 } } class At { constructor(t, i) { this.Gt = new F, this._h = t, this.uh = i } Tt() { return this.Gt.ht({ Qi: this.uh.Qi(), ...Vt(this._h) }), this.Gt } } class Bt extends L { constructor(t, i) { super(), this._h = t, this.qi = i } ji(t, i, n) { const s = Vt(this._h); n.X = s.X, t.R = s.R; const e = 2 / 12 * this.qi.k(); n.Ti = e, n.Ri = e, n.Vi = s.Vi, n.Ii = s.Ii, t.ri = s.ri, t.Et = s.Et, t.pi = s.pi } } class zt extends Rt { constructor(t, i) { super(t), this.dh = null, this.fh = null, this.ph = null, this.mh = null, this.ge = i } un() { const t = this.ah.timeAxisViews?.() ?? []; if (this.dh?.sh === t) return this.dh.eh; const i = this.ge.Qt().At(), n = t.map((t => new At(t, i))); return this.dh = { sh: t, eh: n }, n } Nn() { const t = this.ah.priceAxisViews?.() ?? []; if (this.fh?.sh === t) return this.fh.eh; const i = this.ge.Wt(), n = t.map((t => new Bt(t, i))); return this.fh = { sh: t, eh: n }, n } wh() { const t = this.ah.priceAxisPaneViews?.() ?? []; if (this.ph?.sh === t) return this.ph.eh; const i = t.map((t => new It(t))); return this.ph = { sh: t, eh: i }, i } gh() { const t = this.ah.timeAxisPaneViews?.() ?? []; if (this.mh?.sh === t) return this.mh.eh; const i = t.map((t => new It(t))); return this.mh = { sh: t, eh: i }, i } Mh(t, i) { return this.ah.autoscaleInfo?.(t, i) ?? null } } function Ot(t, i, n, s) { t.forEach((t => { i(t).forEach((t => { t.rh() === n && s.push(t) })) })) } function Lt(t) { return t.Ln() } function Nt(t) { return t.wh() } function Wt(t) { return t.gh() } const Ft = ["Area", "Line", "Baseline"]; class Ht extends mt { constructor(t, i, n, s, e) { super(t), this.qt = new yt, this.er = new ot(this), this.bh = [], this.xh = new rt(this), this.Sh = null, this.Ch = null, this.yh = null, this.kh = [], this.Sn = n, this.Ph = i; const r = new _t(this); this.pn = [r], this.rr = new nt(r, this, t), Ft.includes(this.Ph) && (this.Sh = new lt(this)), this.Th(), this.nh = s(this, this.Qt(), e) } m() { null !== this.yh && clearTimeout(this.yh) } Ve(t) { return this.Sn.priceLineColor || t } ke(t) { const i = { Pe: !0 }, n = this.Wt(); if (this.Qt().At().Zi() || n.Zi() || this.qt.Zi()) return i; const s = this.Qt().At().ye(), e = this.zt(); if (null === s || null === e) return i; let r, h; if (t) { const t = this.qt.Br(); if (null === t) return i; r = t, h = t.Re } else { const t = this.qt.Wr(s.bi(), -1); if (null === t) return i; if (r = this.qt.Pr(t.Re), null === r) return i; h = t.Re } const a = r.Ft[3], l = this.Rh().Dr(h, { Ft: r }), o = n.Nt(a, e.Ft); return { Pe: !1, gt: a, ri: n.Xi(a, e.Ft), Le: n.Dh(a), Ne: n.Eh(a, e.Ft), R: l.cr, Vi: o, Re: h } } Rh() { return null !== this.Ch || (this.Ch = new gt(this)), this.Ch } N() { return this.Sn } hr(t) { const i = t.priceScaleId; void 0 !== i && i !== this.Sn.priceScaleId && this.Qt().Ih(this, i), _(this.Sn, t), void 0 !== t.priceFormat && (this.Th(), this.Qt().Vh()), this.Qt().Ah(this), this.Qt().Bh(), this.nh.kt("options") } ht(t, i) { this.qt.ht(t), this.nh.kt("data"), null !== this.Sh && (i && i.zh ? this.Sh.be() : 0 === t.length && this.Sh.Me()); const n = this.Qt().Hs(this); this.Qt().Oh(n), this.Qt().Ah(this), this.Qt().Bh(), this.Qt().ar() } Lh(t) { const i = new vt(this, t); return this.bh.push(i), this.Qt().Ah(this), i } Nh(t) { const i = this.bh.indexOf(t); -1 !== i && this.bh.splice(i, 1), this.Qt().Ah(this) } Wh() { return this.bh } Rr() { return this.Ph } zt() { const t = this.Fh(); return null === t ? null : { Ft: t.Ft[3], Hh: t.wt } } Fh() { const t = this.Qt().At().ye(); if (null === t) return null; const i = t.Uh(); return this.qt.Wr(i, 1) } Yn() { return this.qt } $h(t) { const i = this.qt.Pr(t); return null === i ? null : "Bar" === this.Ph || "Candlestick" === this.Ph || "Custom" === this.Ph ? { jh: i.Ft[0], qh: i.Ft[1], Yh: i.Ft[2], Zh: i.Ft[3] } : i.Ft[3] } Kh(t) { const i = []; Ot(this.kh, Lt, "top", i); const n = this.Sh; return null !== n && n.Et() ? (null === this.yh && n.Se() && (this.yh = setTimeout((() => { this.yh = null, this.Qt().Xh() }), 0)), n.xe(), i.unshift(n), i) : i } Ln() { const t = []; this.Gh() || t.push(this.xh), t.push(this.nh, this.er); const i = this.bh.map((t => t.lr())); return t.push(...i), Ot(this.kh, Lt, "normal", t), t } Jh() { return this.Qh(Lt, "bottom") } ta(t) { return this.Qh(Nt, t) } ia(t) { return this.Qh(Wt, t) } na(t, i) { return this.kh.map((n => n.Ys(t, i))).filter((t => null !== t)) } _n() { return [this.rr, ...this.bh.map((t => t._r()))] } Nn(t, i) { if (i !== this.en && !this.Gh()) return []; const n = [...this.pn]; for (const t of this.bh) n.push(t.ur()); return this.kh.forEach((t => { n.push(...t.Nn()) })), n } un() { const t = []; return this.kh.forEach((i => { t.push(...i.un()) })), t } Mh(t, i) { if (void 0 !== this.Sn.autoscaleInfoProvider) { const n = this.Sn.autoscaleInfoProvider((() => { const n = this.sa(t, i); return null === n ? null : n.Ke() })); return dt.Xe(n) } return this.sa(t, i) } ea() { return this.Sn.priceFormat.minMove } ra() { return this.ha } On() { this.nh.kt(); for (const t of this.pn) t.kt(); for (const t of this.bh) t.kt(); this.er.kt(), this.xh.kt(), this.Sh?.kt(), this.kh.forEach((t => t.On())) } Wt() { return a(super.Wt()) } Bt(t) { if (!(("Line" === this.Ph || "Area" === this.Ph || "Baseline" === this.Ph) && this.Sn.crosshairMarkerVisible)) return null; const i = this.qt.Pr(t); if (null === i) return null; return { gt: i.Ft[3], ft: this.aa(), Ht: this.la(), Lt: this.oa(), Ot: this._a(t) } } Ae() { return this.Sn.title } Et() { return this.Sn.visible } ua(t) { this.kh.push(new zt(t, this)) } ca(t) { this.kh = this.kh.filter((i => i.oh() !== t)) } da() { if ("Custom" === this.Ph) return t => this.nh.fa(t) } pa() { if ("Custom" === this.Ph) return t => this.nh.va(t) } ma() { return this.qt.jr() } Gh() { return !q(this.Wt().wa()) } sa(t, i) { if (!c(t) || !c(i) || this.qt.Zi()) return null; const n = "Line" === this.Ph || "Area" === this.Ph || "Baseline" === this.Ph || "Histogram" === this.Ph ? [3] : [2, 1], s = this.qt.Ur(t, i, n); let e = null !== s ? new ct(s.Jr, s.Qr) : null, r = null; if ("Histogram" === this.Rr()) { const t = this.Sn.base, i = new ct(t, t); e = null !== e ? e.ps(i) : i } return this.kh.forEach((n => { const s = n.Mh(t, i); if (s?.priceRange) { const t = new ct(s.priceRange.minValue, s.priceRange.maxValue); e = null !== e ? e.ps(t) : t } s?.margins && (r = s.margins) })), new dt(e, r) } aa() { switch (this.Ph) { case "Line": case "Area": case "Baseline": return this.Sn.crosshairMarkerRadius }return 0 } la() { switch (this.Ph) { case "Line": case "Area": case "Baseline": { const t = this.Sn.crosshairMarkerBorderColor; if (0 !== t.length) return t } }return null } oa() { switch (this.Ph) { case "Line": case "Area": case "Baseline": return this.Sn.crosshairMarkerBorderWidth }return 0 } _a(t) { switch (this.Ph) { case "Line": case "Area": case "Baseline": { const t = this.Sn.crosshairMarkerBackgroundColor; if (0 !== t.length) return t } }return this.Rh().Dr(t).cr } Th() { switch (this.Sn.priceFormat.type) { case "custom": this.ha = { format: this.Sn.priceFormat.formatter }; break; case "volume": this.ha = new J(this.Sn.priceFormat.precision); break; case "percent": this.ha = new G(this.Sn.priceFormat.precision); break; default: { const t = Math.pow(10, this.Sn.priceFormat.precision); this.ha = new X(t, this.Sn.priceFormat.minMove * t) } }null !== this.en && this.en.ga() } Qh(t, i) { const n = []; return Ot(this.kh, t, i, n), n } } class Ut { constructor(t) { this.Sn = t } Ma(t, i, n) { let s = t; if (0 === this.Sn.mode) return s; const e = n.yn(), r = e.zt(); if (null === r) return s; const h = e.Nt(t, r), a = n.ba().filter((t => t instanceof Ht)).reduce(((t, s) => { if (n.Us(s) || !s.Et()) return t; const e = s.Wt(), r = s.Yn(); if (e.Zi() || !r.Te(i)) return t; const h = r.Pr(i); if (null === h) return t; const a = l(s.zt()); return t.concat([e.Nt(h.Ft[3], a.Ft)]) }), []); if (0 === a.length) return s; a.sort(((t, i) => Math.abs(t - h) - Math.abs(i - h))); const o = a[0]; return s = e.kn(o, r), s } } class $t extends y { constructor() { super(...arguments), this.qt = null } ht(t) { this.qt = t } et({ context: t, bitmapSize: i, horizontalPixelRatio: n, verticalPixelRatio: e }) { if (null === this.qt) return; const r = Math.max(1, Math.floor(n)); t.lineWidth = r, function (t, i) { t.save(), t.lineWidth % 2 && t.translate(.5, .5), i(), t.restore() }(t, (() => { const h = a(this.qt); if (h.xa) { t.strokeStyle = h.Sa, s(t, h.Ca), t.beginPath(); for (const s of h.ya) { const e = Math.round(s.ka * n); t.moveTo(e, -r), t.lineTo(e, i.height + r) } t.stroke() } if (h.Pa) { t.strokeStyle = h.Ta, s(t, h.Ra), t.beginPath(); for (const n of h.Da) { const s = Math.round(n.ka * e); t.moveTo(-r, s), t.lineTo(i.width + r, s) } t.stroke() } })) } } class jt { constructor(t) { this.Gt = new $t, this.St = !0, this.yt = t } kt() { this.St = !0 } Tt() { if (this.St) { const t = this.yt.Qt().N().grid, i = { Pa: t.horzLines.visible, xa: t.vertLines.visible, Ta: t.horzLines.color, Sa: t.vertLines.color, Ra: t.horzLines.style, Ca: t.vertLines.style, Da: this.yt.yn().Ea(), ya: (this.yt.Qt().At().Ea() || []).map((t => ({ ka: t.coord }))) }; this.Gt.ht(i), this.St = !1 } return this.Gt } } class qt { constructor(t) { this.nh = new jt(t) } lr() { return this.nh } } const Yt = { Ia: 4, Va: 1e-4 }; function Zt(t, i) { const n = 100 * (t - i) / i; return i < 0 ? -n : n } function Kt(t, i) { const n = Zt(t.$e(), i), s = Zt(t.je(), i); return new ct(n, s) } function Xt(t, i) { const n = 100 * (t - i) / i + 100; return i < 0 ? -n : n } function Gt(t, i) { const n = Xt(t.$e(), i), s = Xt(t.je(), i); return new ct(n, s) } function Jt(t, i) { const n = Math.abs(t); if (n < 1e-15) return 0; const s = Math.log10(n + i.Va) + i.Ia; return t < 0 ? -s : s } function Qt(t, i) { const n = Math.abs(t); if (n < 1e-15) return 0; const s = Math.pow(10, n - i.Ia) - i.Va; return t < 0 ? -s : s } function ti(t, i) { if (null === t) return null; const n = Jt(t.$e(), i), s = Jt(t.je(), i); return new ct(n, s) } function ii(t, i) { if (null === t) return null; const n = Qt(t.$e(), i), s = Qt(t.je(), i); return new ct(n, s) } function ni(t) { if (null === t) return Yt; const i = Math.abs(t.je() - t.$e()); if (i >= 1 || i < 1e-15) return Yt; const n = Math.ceil(Math.abs(Math.log10(i))), s = Yt.Ia + n; return { Ia: s, Va: 1 / Math.pow(10, s) } } function si(t, i, n) { return Math.min(Math.max(t, i), n) } function ei(t, i, n) { return i - t <= n } function ri(t) { const i = Math.ceil(t); return i % 2 == 0 ? i - 1 : i } class hi { constructor(t, i) { if (this.Aa = t, this.Ba = i, function (t) { if (t < 0) return !1; for (let i = t; i > 1; i /= 10)if (i % 10 != 0) return !1; return !0 }(this.Aa)) this.za = [2, 2.5, 2]; else { this.za = []; for (let t = this.Aa; 1 !== t;) { if (t % 2 == 0) this.za.push(2), t /= 2; else { if (t % 5 != 0) throw new Error("unexpected base"); this.za.push(2, 2.5), t /= 5 } if (this.za.length > 100) throw new Error("something wrong with base") } } } Oa(t, i, n) { const s = 0 === this.Aa ? 0 : 1 / this.Aa; let e = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t - i)))), r = 0, h = this.Ba[0]; for (; ;) { const t = ei(e, s, 1e-14) && e > s + 1e-14, i = ei(e, n * h, 1e-14), a = ei(e, 1, 1e-14); if (!(t && i && a)) break; e /= h, h = this.Ba[++r % this.Ba.length] } if (e <= s + 1e-14 && (e = s), e = Math.max(1, e), this.za.length > 0 && (a = e, l = 1, o = 1e-14, Math.abs(a - l) < o)) for (r = 0, h = this.za[0]; ei(e, n * h, 1e-14) && e > s + 1e-14;)e /= h, h = this.za[++r % this.za.length]; var a, l, o; return e } } class ai { constructor(t, i, n, s) { this.La = [], this.qi = t, this.Aa = i, this.Na = n, this.Wa = s } Oa(t, i) { if (t < i) throw new Error("high < low"); const n = this.qi.$t(), s = (t - i) * this.Fa() / n, e = new hi(this.Aa, [2, 2.5, 2]), r = new hi(this.Aa, [2, 2, 2.5]), h = new hi(this.Aa, [2.5, 2, 2]), a = []; return a.push(e.Oa(t, i, s), r.Oa(t, i, s), h.Oa(t, i, s)), function (t) { if (t.length < 1) throw Error("array is empty"); let i = t[0]; for (let n = 1; n < t.length; ++n)t[n] < i && (i = t[n]); return i }(a) } Ha() { const t = this.qi, i = t.zt(); if (null === i) return void (this.La = []); const n = t.$t(), s = this.Na(n - 1, i), e = this.Na(0, i), r = this.qi.N().entireTextOnly ? this.Ua() / 2 : 0, h = r, a = n - 1 - r, l = Math.max(s, e), o = Math.min(s, e); if (l === o) return void (this.La = []); let _ = this.Oa(l, o), u = l % _; u += u < 0 ? _ : 0; const c = l >= o ? 1 : -1; let d = null, f = 0; for (let n = l - u; n > o; n -= _) { const s = this.Wa(n, i, !0); null !== d && Math.abs(s - d) < this.Fa() || (s < h || s > a || (f < this.La.length ? (this.La[f].ka = s, this.La[f].$a = t.ja(n)) : this.La.push({ ka: s, $a: t.ja(n) }), f++, d = s, t.qa() && (_ = this.Oa(n * c, o)))) } this.La.length = f } Ea() { return this.La } Ua() { return this.qi.k() } Fa() { return Math.ceil(2.5 * this.Ua()) } } function li(t) { return t.slice().sort(((t, i) => a(t.hn()) - a(i.hn()))) } var oi; !function (t) { t[t.Normal = 0] = "Normal", t[t.Logarithmic = 1] = "Logarithmic", t[t.Percentage = 2] = "Percentage", t[t.IndexedTo100 = 3] = "IndexedTo100" }(oi || (oi = {})); const _i = new G, ui = new X(100, 1); class ci { constructor(t, i, n, s, e) { this.Ya = 0, this.Za = null, this.Ge = null, this.Ka = null, this.Xa = { Ga: !1, Ja: null }, this.Qa = 0, this.tl = 0, this.il = new o, this.nl = new o, this.sl = [], this.el = null, this.rl = null, this.hl = null, this.al = null, this.ha = ui, this.ll = ni(null), this.ol = t, this.Sn = i, this._l = n, this.ul = s, this.cl = e, this.dl = new ai(this, 100, this.fl.bind(this), this.pl.bind(this)) } wa() { return this.ol } N() { return this.Sn } hr(t) { if (_(this.Sn, t), this.ga(), void 0 !== t.mode && this.vl({ ie: t.mode }), void 0 !== t.scaleMargins) { const i = h(t.scaleMargins.top), n = h(t.scaleMargins.bottom); if (i < 0 || i > 1) throw new Error(`Invalid top margin - expect value between 0 and 1, given=${i}`); if (n < 0 || n > 1) throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${n}`); if (i + n > 1) throw new Error(`Invalid margins - sum of margins must be less than 1, given=${i + n}`); this.ml(), this.rl = null } } wl() { return this.Sn.autoScale } qa() { return 1 === this.Sn.mode } Oe() { return 2 === this.Sn.mode } gl() { return 3 === this.Sn.mode } ie() { return { Qn: this.Sn.autoScale, Ml: this.Sn.invertScale, ie: this.Sn.mode } } vl(t) { const i = this.ie(); let n = null; void 0 !== t.Qn && (this.Sn.autoScale = t.Qn), void 0 !== t.ie && (this.Sn.mode = t.ie, 2 !== t.ie && 3 !== t.ie || (this.Sn.autoScale = !0), this.Xa.Ga = !1), 1 === i.ie && t.ie !== i.ie && (!function (t, i) { if (null === t) return !1; const n = Qt(t.$e(), i), s = Qt(t.je(), i); return isFinite(n) && isFinite(s) }(this.Ge, this.ll) ? this.Sn.autoScale = !0 : (n = ii(this.Ge, this.ll), null !== n && this.bl(n))), 1 === t.ie && t.ie !== i.ie && (n = ti(this.Ge, this.ll), null !== n && this.bl(n)); const s = i.ie !== this.Sn.mode; s && (2 === i.ie || this.Oe()) && this.ga(), s && (3 === i.ie || this.gl()) && this.ga(), void 0 !== t.Ml && i.Ml !== t.Ml && (this.Sn.invertScale = t.Ml, this.xl()), this.nl.p(i, this.ie()) } Sl() { return this.nl } k() { return this._l.fontSize } $t() { return this.Ya } Cl(t) { this.Ya !== t && (this.Ya = t, this.ml(), this.rl = null) } yl() { if (this.Za) return this.Za; const t = this.$t() - this.kl() - this.Pl(); return this.Za = t, t } Qe() { return this.Tl(), this.Ge } bl(t, i) { const n = this.Ge; (i || null === n && null !== t || null !== n && !n.He(t)) && (this.rl = null, this.Ge = t) } Zi() { return this.Tl(), 0 === this.Ya || !this.Ge || this.Ge.Zi() } Rl(t) { return this.Ml() ? t : this.$t() - 1 - t } Nt(t, i) { return this.Oe() ? t = Zt(t, i) : this.gl() && (t = Xt(t, i)), this.pl(t, i) } Dl(t, i, n) { this.Tl(); const s = this.Pl(), e = a(this.Qe()), r = e.$e(), h = e.je(), l = this.yl() - 1, o = this.Ml(), _ = l / (h - r), u = void 0 === n ? 0 : n.from, c = void 0 === n ? t.length : n.to, d = this.El(); for (let n = u; n < c; n++) { const e = t[n], h = e.gt; if (isNaN(h)) continue; let a = h; null !== d && (a = d(e.gt, i)); const l = s + _ * (a - r), u = o ? l : this.Ya - 1 - l; e.ut = u } } Il(t, i, n) { this.Tl(); const s = this.Pl(), e = a(this.Qe()), r = e.$e(), h = e.je(), l = this.yl() - 1, o = this.Ml(), _ = l / (h - r), u = void 0 === n ? 0 : n.from, c = void 0 === n ? t.length : n.to, d = this.El(); for (let n = u; n < c; n++) { const e = t[n]; let h = e.jh, a = e.qh, l = e.Yh, u = e.Zh; null !== d && (h = d(e.jh, i), a = d(e.qh, i), l = d(e.Yh, i), u = d(e.Zh, i)); let c = s + _ * (h - r), f = o ? c : this.Ya - 1 - c; e.Vl = f, c = s + _ * (a - r), f = o ? c : this.Ya - 1 - c, e.Al = f, c = s + _ * (l - r), f = o ? c : this.Ya - 1 - c, e.Bl = f, c = s + _ * (u - r), f = o ? c : this.Ya - 1 - c, e.zl = f } } kn(t, i) { const n = this.fl(t, i); return this.Ol(n, i) } Ol(t, i) { let n = t; return this.Oe() ? n = function (t, i) { return i < 0 && (t = -t), t / 100 * i + i }(n, i) : this.gl() && (n = function (t, i) { return t -= 100, i < 0 && (t = -t), t / 100 * i + i }(n, i)), n } ba() { return this.sl } Dt() { if (this.el) return this.el; let t = []; for (let i = 0; i < this.sl.length; i++) { const n = this.sl[i]; null === n.hn() && n.an(i + 1), t.push(n) } return t = li(t), this.el = t, this.el } Ll(t) { -1 === this.sl.indexOf(t) && (this.sl.push(t), this.ga(), this.Nl()) } Wl(t) { const i = this.sl.indexOf(t); if (-1 === i) throw new Error("source is not attached to scale"); this.sl.splice(i, 1), 0 === this.sl.length && (this.vl({ Qn: !0 }), this.bl(null)), this.ga(), this.Nl() } zt() { let t = null; for (const i of this.sl) { const n = i.zt(); null !== n && ((null === t || n.Hh < t.Hh) && (t = n)) } return null === t ? null : t.Ft } Ml() { return this.Sn.invertScale } Ea() { const t = null === this.zt(); if (null !== this.rl && (t || this.rl.Fl === t)) return this.rl.Ea; this.dl.Ha(); const i = this.dl.Ea(); return this.rl = { Ea: i, Fl: t }, this.il.p(), i } Hl() { return this.il } Ul(t) { this.Oe() || this.gl() || null === this.hl && null === this.Ka && (this.Zi() || (this.hl = this.Ya - t, this.Ka = a(this.Qe()).Ue())) } $l(t) { if (this.Oe() || this.gl()) return; if (null === this.hl) return; this.vl({ Qn: !1 }), (t = this.Ya - t) < 0 && (t = 0); let i = (this.hl + .2 * (this.Ya - 1)) / (t + .2 * (this.Ya - 1)); const n = a(this.Ka).Ue(); i = Math.max(i, .1), n.Ye(i), this.bl(n) } jl() { this.Oe() || this.gl() || (this.hl = null, this.Ka = null) } ql(t) { this.wl() || null === this.al && null === this.Ka && (this.Zi() || (this.al = t, this.Ka = a(this.Qe()).Ue())) } Yl(t) { if (this.wl()) return; if (null === this.al) return; const i = a(this.Qe()).qe() / (this.yl() - 1); let n = t - this.al; this.Ml() && (n *= -1); const s = n * i, e = a(this.Ka).Ue(); e.Ze(s), this.bl(e, !0), this.rl = null } Zl() { this.wl() || null !== this.al && (this.al = null, this.Ka = null) } ra() { return this.ha || this.ga(), this.ha } Xi(t, i) { switch (this.Sn.mode) { case 2: return this.Kl(Zt(t, i)); case 3: return this.ra().format(Xt(t, i)); default: return this.sr(t) } } ja(t) { switch (this.Sn.mode) { case 2: return this.Kl(t); case 3: return this.ra().format(t); default: return this.sr(t) } } Dh(t) { return this.sr(t, a(this.Xl()).ra()) } Eh(t, i) { return t = Zt(t, i), this.Kl(t, _i) } Gl() { return this.sl } Jl(t) { this.Xa = { Ja: t, Ga: !1 } } On() { this.sl.forEach((t => t.On())) } ga() { this.rl = null; const t = this.Xl(); let i = 100; null !== t && (i = Math.round(1 / t.ea())), this.ha = ui, this.Oe() ? (this.ha = _i, i = 100) : this.gl() ? (this.ha = new X(100, 1), i = 100) : null !== t && (this.ha = t.ra()), this.dl = new ai(this, i, this.fl.bind(this), this.pl.bind(this)), this.dl.Ha() } Nl() { this.el = null } Ki() { return this.cl } Xl() { return this.sl[0] || null } kl() { return this.Ml() ? this.Sn.scaleMargins.bottom * this.$t() + this.tl : this.Sn.scaleMargins.top * this.$t() + this.Qa } Pl() { return this.Ml() ? this.Sn.scaleMargins.top * this.$t() + this.Qa : this.Sn.scaleMargins.bottom * this.$t() + this.tl } Tl() { this.Xa.Ga || (this.Xa.Ga = !0, this.Ql()) } ml() { this.Za = null } pl(t, i) { if (this.Tl(), this.Zi()) return 0; t = this.qa() && t ? Jt(t, this.ll) : t; const n = a(this.Qe()), s = this.Pl() + (this.yl() - 1) * (t - n.$e()) / n.qe(); return this.Rl(s) } fl(t, i) { if (this.Tl(), this.Zi()) return 0; const n = this.Rl(t), s = a(this.Qe()), e = s.$e() + s.qe() * ((n - this.Pl()) / (this.yl() - 1)); return this.qa() ? Qt(e, this.ll) : e } xl() { this.rl = null, this.dl.Ha() } Ql() { const t = this.Xa.Ja; if (null === t) return; let i = null; const n = this.Gl(); let s = 0, e = 0; for (const r of n) { if (!r.Et()) continue; const n = r.zt(); if (null === n) continue; const h = r.Mh(t.Uh(), t.bi()); let l = h && h.Qe(); if (null !== l) { switch (this.Sn.mode) { case 1: l = ti(l, this.ll); break; case 2: l = Kt(l, n.Ft); break; case 3: l = Gt(l, n.Ft) }if (i = null === i ? l : i.ps(a(l)), null !== h) { const t = h.tr(); null !== t && (s = Math.max(s, t.above), e = Math.max(e, t.below)) } } } if (s === this.Qa && e === this.tl || (this.Qa = s, this.tl = e, this.rl = null, this.ml()), null !== i) { if (i.$e() === i.je()) { const t = this.Xl(), n = 5 * (null === t || this.Oe() || this.gl() ? 1 : t.ea()); this.qa() && (i = ii(i, this.ll)), i = new ct(i.$e() - n, i.je() + n), this.qa() && (i = ti(i, this.ll)) } if (this.qa()) { const t = ii(i, this.ll), n = ni(t); if (r = n, h = this.ll, r.Ia !== h.Ia || r.Va !== h.Va) { const s = null !== this.Ka ? ii(this.Ka, this.ll) : null; this.ll = n, i = ti(t, n), null !== s && (this.Ka = ti(s, n)) } } this.bl(i) } else null === this.Ge && (this.bl(new ct(-.5, .5)), this.ll = ni(null)); var r, h; this.Xa.Ga = !0 } El() { return this.Oe() ? Zt : this.gl() ? Xt : this.qa() ? t => Jt(t, this.ll) : null } io(t, i, n) { return void 0 === i ? (void 0 === n && (n = this.ra()), n.format(t)) : i(t) } sr(t, i) { return this.io(t, this.ul.priceFormatter, i) } Kl(t, i) { return this.io(t, this.ul.percentageFormatter, i) } } function di(t) { return t instanceof Ht } class fi { constructor(t, i) { this.sl = [], this.no = new Map, this.Ya = 0, this.so = 0, this.eo = 1e3, this.el = null, this.ro = new o, this.kh = [], this.uh = t, this.tn = i, this.ho = new qt(this); const n = i.N(); this.ao = this.lo("left", n.leftPriceScale), this.oo = this.lo("right", n.rightPriceScale), this.ao.Sl().i(this._o.bind(this, this.ao), this), this.oo.Sl().i(this._o.bind(this, this.oo), this), this.uo(n) } uo(t) { if (t.leftPriceScale && this.ao.hr(t.leftPriceScale), t.rightPriceScale && this.oo.hr(t.rightPriceScale), t.localization && (this.ao.ga(), this.oo.ga()), t.overlayPriceScales) { const i = Array.from(this.no.values()); for (const n of i) { const i = a(n[0].Wt()); i.hr(t.overlayPriceScales), t.localization && i.ga() } } } co(t) { switch (t) { case "left": return this.ao; case "right": return this.oo }return this.no.has(t) ? h(this.no.get(t))[0].Wt() : null } m() { this.Qt().do().u(this), this.ao.Sl().u(this), this.oo.Sl().u(this), this.sl.forEach((t => { t.m && t.m() })), this.kh = this.kh.filter((t => { const i = t.oh(); return i.detached && i.detached(), !1 })), this.ro.p() } fo() { return this.eo } po(t) { this.eo = t } Qt() { return this.tn } Qi() { return this.so } $t() { return this.Ya } vo(t) { this.so = t, this.mo() } Cl(t) { this.Ya = t, this.ao.Cl(t), this.oo.Cl(t), this.sl.forEach((i => { if (this.Us(i)) { const n = i.Wt(); null !== n && n.Cl(t) } })), this.mo() } wo() { return this.sl.filter(di) } ba() { return this.sl } Us(t) { const i = t.Wt(); return null === i || this.ao !== i && this.oo !== i } Ll(t, i, n) { const s = void 0 !== n ? n : this.bo().Mo + 1; this.xo(t, i, s) } Wl(t) { const i = this.sl.indexOf(t); r(-1 !== i, "removeDataSource: invalid data source"), this.sl.splice(i, 1); const n = a(t.Wt()).wa(); if (this.no.has(n)) { const i = h(this.no.get(n)), s = i.indexOf(t); -1 !== s && (i.splice(s, 1), 0 === i.length && this.no.delete(n)) } const s = t.Wt(); s && s.ba().indexOf(t) >= 0 && s.Wl(t), null !== s && (s.Nl(), this.So(s)), this.el = null } js(t) { return t === this.ao ? "left" : t === this.oo ? "right" : "overlay" } Co() { return this.ao } yo() { return this.oo } ko(t, i) { t.Ul(i) } Po(t, i) { t.$l(i), this.mo() } To(t) { t.jl() } Ro(t, i) { t.ql(i) } Do(t, i) { t.Yl(i), this.mo() } Eo(t) { t.Zl() } mo() { this.sl.forEach((t => { t.On() })) } yn() { let t = null; return this.tn.N().rightPriceScale.visible && 0 !== this.oo.ba().length ? t = this.oo : this.tn.N().leftPriceScale.visible && 0 !== this.ao.ba().length ? t = this.ao : 0 !== this.sl.length && (t = this.sl[0].Wt()), null === t && (t = this.oo), t } $s() { let t = null; return this.tn.N().rightPriceScale.visible ? t = this.oo : this.tn.N().leftPriceScale.visible && (t = this.ao), t } So(t) { null !== t && t.wl() && this.Io(t) } Vo(t) { const i = this.uh.ye(); t.vl({ Qn: !0 }), null !== i && t.Jl(i), this.mo() } Ao() { this.Io(this.ao), this.Io(this.oo) } Bo() { this.So(this.ao), this.So(this.oo), this.sl.forEach((t => { this.Us(t) && this.So(t.Wt()) })), this.mo(), this.tn.ar() } Dt() { return null === this.el && (this.el = li(this.sl)), this.el } It() { return this.Dt().filter(di) } zo() { return this.ro } Oo() { return this.ho } ua(t) { this.kh.push(new Dt(t)) } ca(t) { this.kh = this.kh.filter((i => i.oh() !== t)), t.detached && t.detached(), this.tn.ar() } Lo() { return this.kh } na(t, i) { return this.kh.map((n => n.Ys(t, i))).filter((t => null !== t)) } Io(t) { const i = t.Gl(); if (i && i.length > 0 && !this.uh.Zi()) { const i = this.uh.ye(); null !== i && t.Jl(i) } t.On() } bo() { const t = this.Dt(); if (0 === t.length) return { No: 0, Mo: 0 }; let i = 0, n = 0; for (let s = 0; s < t.length; s++) { const e = t[s].hn(); null !== e && (e < i && (i = e), e > n && (n = e)) } return { No: i, Mo: n } } xo(t, i, n) { let s = this.co(i); if (null === s && (s = this.lo(i, this.tn.N().overlayPriceScales)), this.sl.push(t), !q(i)) { const n = this.no.get(i) || []; n.push(t), this.no.set(i, n) } s.Ll(t), t.ln(s), t.an(n), this.So(s), this.el = null } _o(t, i, n) { i.ie !== n.ie && this.Io(t) } lo(t, i) { const n = { visible: !0, autoScale: !0, ...p(i) }, s = new ci(t, n, this.tn.N().layout, this.tn.N().localization, this.tn.Ki()); return s.Cl(this.$t()), s } } function pi(t) { return { Wo: t.Wo, Fo: { Zs: t.Ho.externalId }, Uo: t.Ho.cursorStyle } } function vi(t, i, n, s) { for (const e of t) { const t = e.Tt(s); if (null !== t && t.Ys) { const s = t.Ys(i, n); if (null !== s) return { $o: e, Fo: s } } } return null } function mi(t) { return void 0 !== t.Ln } function wi(t, i, n) { const s = [t, ...t.Dt()], e = function (t, i, n) { let s, e; for (const a of t) { const t = a.na?.(i, n) ?? []; for (const i of t) r = i.zOrder, h = s?.zOrder, (!h || "top" === r && "top" !== h || "normal" === r && "bottom" === h) && (s = i, e = a) } var r, h; return s && e ? { Ho: s, Wo: e } : null }(s, i, n); if ("top" === e?.Ho.zOrder) return pi(e); for (const r of s) { if (e && e.Wo === r && "bottom" !== e.Ho.zOrder && !e.Ho.isBackground) return pi(e); if (mi(r)) { const s = vi(r.Ln(t), i, n, t); if (null !== s) return { Wo: r, $o: s.$o, Fo: s.Fo } } if (e && e.Wo === r && "bottom" !== e.Ho.zOrder && e.Ho.isBackground) return pi(e) } return e?.Ho ? pi(e) : null } class gi { constructor(t, i, n = 50) { this.ks = 0, this.Ps = 1, this.Ts = 1, this.Ds = new Map, this.Rs = new Map, this.jo = t, this.qo = i, this.Es = n } Yo(t) { const i = t.time, n = this.qo.cacheKey(i), s = this.Ds.get(n); if (void 0 !== s) return s.Zo; if (this.ks === this.Es) { const t = this.Rs.get(this.Ts); this.Rs.delete(this.Ts), this.Ds.delete(h(t)), this.Ts++, this.ks-- } const e = this.jo(t); return this.Ds.set(n, { Zo: e, Bs: this.Ps }), this.Rs.set(this.Ps, n), this.ks++, this.Ps++, e } } class Mi { constructor(t, i) { r(t <= i, "right should be >= left"), this.Ko = t, this.Xo = i } Uh() { return this.Ko } bi() { return this.Xo } Go() { return this.Xo - this.Ko + 1 } Te(t) { return this.Ko <= t && t <= this.Xo } He(t) { return this.Ko === t.Uh() && this.Xo === t.bi() } } function bi(t, i) { return null === t || null === i ? t === i : t.He(i) } class xi { constructor() { this.Jo = new Map, this.Ds = null, this.Qo = !1 } t_(t) { this.Qo = t, this.Ds = null } i_(t, i) { this.n_(i), this.Ds = null; for (let n = i; n < t.length; ++n) { const i = t[n]; let s = this.Jo.get(i.timeWeight); void 0 === s && (s = [], this.Jo.set(i.timeWeight, s)), s.push({ index: n, time: i.time, weight: i.timeWeight, originalTime: i.originalTime }) } } s_(t, i, n, s, e) { const r = Math.ceil(i / t); return null !== this.Ds && this.Ds.e_ === r && e === this.Ds.r_ && n === this.Ds.h_ || (this.Ds = { r_: e, h_: n, Ea: this.a_(r, n, s), e_: r }), this.Ds.Ea } n_(t) { if (0 === t) return void this.Jo.clear(); const i = []; this.Jo.forEach(((n, s) => { t <= n[0].index ? i.push(s) : n.splice(bt(n, t, (i => i.index < t)), 1 / 0) })); for (const t of i) this.Jo.delete(t) } a_(t, i, n) { let s = []; const e = t => !i || n.has(t.index); for (const i of Array.from(this.Jo.keys()).sort(((t, i) => i - t))) { if (!this.Jo.get(i)) continue; const n = s; s = []; const r = n.length; let a = 0; const l = h(this.Jo.get(i)), o = l.length; let _ = 1 / 0, u = -1 / 0; for (let i = 0; i < o; i++) { const h = l[i], o = h.index; for (; a < r;) { const t = n[a], i = t.index; if (!(i < o && e(t))) { _ = i; break } a++, s.push(t), u = i, _ = 1 / 0 } if (_ - o >= t && o - u >= t && e(h)) s.push(h), u = o; else if (this.Qo) return n } for (; a < r; a++)e(n[a]) && s.push(n[a]) } return s } } class Si { constructor(t) { this.l_ = t } o_() { return null === this.l_ ? null : new Mi(Math.floor(this.l_.Uh()), Math.ceil(this.l_.bi())) } __() { return this.l_ } static u_() { return new Si(null) } } function Ci(t, i) { return t.weight > i.weight ? t : i } class yi { constructor(t, i, n, s) { this.so = 0, this.c_ = null, this.d_ = [], this.al = null, this.hl = null, this.f_ = new xi, this.p_ = new Map, this.v_ = Si.u_(), this.m_ = !0, this.w_ = new o, this.g_ = new o, this.M_ = new o, this.b_ = null, this.x_ = null, this.S_ = new Map, this.C_ = -1, this.y_ = [], this.Sn = i, this.ul = n, this.k_ = i.rightOffset, this.P_ = i.barSpacing, this.tn = t, this.qo = s, this.T_(), this.f_.t_(i.uniformDistribution), this.R_() } N() { return this.Sn } D_(t) { _(this.ul, t), this.E_(), this.T_() } hr(t, i) { _(this.Sn, t), this.Sn.fixLeftEdge && this.I_(), this.Sn.fixRightEdge && this.V_(), void 0 !== t.barSpacing && this.tn.cs(t.barSpacing), void 0 !== t.rightOffset && this.tn.ds(t.rightOffset), void 0 === t.minBarSpacing && void 0 === t.maxBarSpacing || this.tn.cs(t.barSpacing ?? this.P_), void 0 !== t.ignoreWhitespaceIndices && t.ignoreWhitespaceIndices !== this.Sn.ignoreWhitespaceIndices && this.R_(), this.E_(), this.T_(), this.M_.p() } Pn(t) { return this.d_[t]?.time ?? null } nn(t) { return this.d_[t] ?? null } A_(t, i) { if (this.d_.length < 1) return null; if (this.qo.key(t) > this.qo.key(this.d_[this.d_.length - 1].time)) return i ? this.d_.length - 1 : null; const n = bt(this.d_, this.qo.key(t), ((t, i) => this.qo.key(t.time) < i)); return this.qo.key(t) < this.qo.key(this.d_[n].time) ? i ? n : null : n } Zi() { return 0 === this.so || 0 === this.d_.length || null === this.c_ } B_() { return this.d_.length > 0 } ye() { return this.z_(), this.v_.o_() } O_() { return this.z_(), this.v_.__() } L_() { const t = this.ye(); if (null === t) return null; const i = { from: t.Uh(), to: t.bi() }; return this.N_(i) } N_(t) { const i = Math.round(t.from), n = Math.round(t.to), s = a(this.W_()), e = a(this.F_()); return { from: a(this.nn(Math.max(s, i))), to: a(this.nn(Math.min(e, n))) } } H_(t) { return { from: a(this.A_(t.from, !0)), to: a(this.A_(t.to, !0)) } } Qi() { return this.so } vo(t) { if (!isFinite(t) || t <= 0) return; if (this.so === t) return; const i = this.O_(), n = this.so; if (this.so = t, this.m_ = !0, this.Sn.lockVisibleTimeRangeOnResize && 0 !== n) { const i = this.P_ * t / n; this.P_ = i } if (this.Sn.fixLeftEdge && null !== i && i.Uh() <= 0) { const i = n - t; this.k_ -= Math.round(i / this.P_) + 1, this.m_ = !0 } this.U_(), this.j_() } jt(t) { if (this.Zi() || !c(t)) return 0; const i = this.q_() + this.k_ - t; return this.so - (i + .5) * this.P_ - 1 } Y_(t, i) { const n = this.q_(), s = void 0 === i ? 0 : i.from, e = void 0 === i ? t.length : i.to; for (let i = s; i < e; i++) { const s = t[i].wt, e = n + this.k_ - s, r = this.so - (e + .5) * this.P_ - 1; t[i]._t = r } } Z_(t, i) { const n = Math.ceil(this.K_(t)); return i && this.Sn.ignoreWhitespaceIndices && !this.X_(n) ? this.G_(n) : n } ds(t) { this.m_ = !0, this.k_ = t, this.j_(), this.tn.J_(), this.tn.ar() } Q_() { return this.P_ } cs(t) { this.tu(t), this.j_(), this.tn.J_(), this.tn.ar() } iu() { return this.k_ } Ea() { if (this.Zi()) return null; if (null !== this.x_) return this.x_; const t = this.P_, i = 5 * (this.tn.N().layout.fontSize + 4) / 8 * (this.Sn.tickMarkMaxCharacterLength || 8), n = Math.round(i / t), s = a(this.ye()), e = Math.max(s.Uh(), s.Uh() - n), r = Math.max(s.bi(), s.bi() - n), h = this.f_.s_(t, i, this.Sn.ignoreWhitespaceIndices, this.S_, this.C_), l = this.W_() + n, o = this.F_() - n, _ = this.nu(), u = this.Sn.fixLeftEdge || _, c = this.Sn.fixRightEdge || _; let d = 0; for (const t of h) { if (!(e <= t.index && t.index <= r)) continue; let n; d < this.y_.length ? (n = this.y_[d], n.coord = this.jt(t.index), n.label = this.su(t), n.weight = t.weight) : (n = { needAlignCoordinate: !1, coord: this.jt(t.index), label: this.su(t), weight: t.weight }, this.y_.push(n)), this.P_ > i / 2 && !_ ? n.needAlignCoordinate = !1 : n.needAlignCoordinate = u && t.index <= l || c && t.index >= o, d++ } return this.y_.length = d, this.x_ = this.y_, this.y_ } eu() { this.m_ = !0, this.cs(this.Sn.barSpacing), this.ds(this.Sn.rightOffset) } ru(t) { this.m_ = !0, this.c_ = t, this.j_(), this.I_() } hu(t, i) { const n = this.K_(t), s = this.Q_(), e = s + i * (s / 10); this.cs(e), this.Sn.rightBarStaysOnScroll || this.ds(this.iu() + (n - this.K_(t))) } Ul(t) { this.al && this.Zl(), null === this.hl && null === this.b_ && (this.Zi() || (this.hl = t, this.au())) } $l(t) { if (null === this.b_) return; const i = si(this.so - t, 0, this.so), n = si(this.so - a(this.hl), 0, this.so); 0 !== i && 0 !== n && this.cs(this.b_.Q_ * i / n) } jl() { null !== this.hl && (this.hl = null, this.lu()) } ql(t) { null === this.al && null === this.b_ && (this.Zi() || (this.al = t, this.au())) } Yl(t) { if (null === this.al) return; const i = (this.al - t) / this.Q_(); this.k_ = a(this.b_).iu + i, this.m_ = !0, this.j_() } Zl() { null !== this.al && (this.al = null, this.lu()) } ou() { this._u(this.Sn.rightOffset) } _u(t, i = 400) { if (!isFinite(t)) throw new RangeError("offset is required and must be finite number"); if (!isFinite(i) || i <= 0) throw new RangeError("animationDuration (optional) must be finite positive number"); const n = this.k_, s = performance.now(); this.tn.ls({ uu: t => (t - s) / i >= 1, cu: e => { const r = (e - s) / i; return r >= 1 ? t : n + (t - n) * r } }) } kt(t, i) { this.m_ = !0, this.d_ = t, this.f_.i_(t, i), this.j_() } du() { return this.w_ } fu() { return this.g_ } pu() { return this.M_ } q_() { return this.c_ || 0 } vu(t) { const i = t.Go(); this.tu(this.so / i), this.k_ = t.bi() - this.q_(), this.j_(), this.m_ = !0, this.tn.J_(), this.tn.ar() } mu() { const t = this.W_(), i = this.F_(); null !== t && null !== i && this.vu(new Mi(t, i + this.Sn.rightOffset)) } wu(t) { const i = new Mi(t.from, t.to); this.vu(i) } sn(t) { return void 0 !== this.ul.timeFormatter ? this.ul.timeFormatter(t.originalTime) : this.qo.formatHorzItem(t.time) } R_() { if (!this.Sn.ignoreWhitespaceIndices) return; this.S_.clear(); const t = this.tn.jn(); for (const i of t) for (const t of i.ma()) this.S_.set(t, !0); this.C_++ } nu() { const t = this.tn.N().handleScroll, i = this.tn.N().handleScale; return !(t.horzTouchDrag || t.mouseWheel || t.pressedMouseMove || t.vertTouchDrag || i.axisDoubleClickReset.time || i.axisPressedMouseMove.time || i.mouseWheel || i.pinch) } W_() { return 0 === this.d_.length ? null : 0 } F_() { return 0 === this.d_.length ? null : this.d_.length - 1 } gu(t) { return (this.so - 1 - t) / this.P_ } K_(t) { const i = this.gu(t), n = this.q_() + this.k_ - i; return Math.round(1e6 * n) / 1e6 } tu(t) { const i = this.P_; this.P_ = t, this.U_(), i !== this.P_ && (this.m_ = !0, this.Mu()) } z_() { if (!this.m_) return; if (this.m_ = !1, this.Zi()) return void this.bu(Si.u_()); const t = this.q_(), i = this.so / this.P_, n = this.k_ + t, s = new Mi(n - i + 1, n); this.bu(new Si(s)) } U_() { const t = si(this.P_, this.xu(), this.Su()); this.P_ !== t && (this.P_ = t, this.m_ = !0) } Su() { return this.Sn.maxBarSpacing > 0 ? this.Sn.maxBarSpacing : .5 * this.so } xu() { return this.Sn.fixLeftEdge && this.Sn.fixRightEdge && 0 !== this.d_.length ? this.so / this.d_.length : this.Sn.minBarSpacing } j_() { const t = this.Cu(); null !== t && this.k_ < t && (this.k_ = t, this.m_ = !0); const i = this.yu(); this.k_ > i && (this.k_ = i, this.m_ = !0) } Cu() { const t = this.W_(), i = this.c_; if (null === t || null === i) return null; return t - i - 1 + (this.Sn.fixLeftEdge ? this.so / this.P_ : Math.min(2, this.d_.length)) } yu() { return this.Sn.fixRightEdge ? 0 : this.so / this.P_ - Math.min(2, this.d_.length) } au() { this.b_ = { Q_: this.Q_(), iu: this.iu() } } lu() { this.b_ = null } su(t) { let i = this.p_.get(t.weight); return void 0 === i && (i = new gi((t => this.ku(t)), this.qo), this.p_.set(t.weight, i)), i.Yo(t) } ku(t) { return this.qo.formatTickmark(t, this.ul) } bu(t) { const i = this.v_; this.v_ = t, bi(i.o_(), this.v_.o_()) || this.w_.p(), bi(i.__(), this.v_.__()) || this.g_.p(), this.Mu() } Mu() { this.x_ = null } E_() { this.Mu(), this.p_.clear() } T_() { this.qo.updateFormatter(this.ul) } I_() { if (!this.Sn.fixLeftEdge) return; const t = this.W_(); if (null === t) return; const i = this.ye(); if (null === i) return; const n = i.Uh() - t; if (n < 0) { const t = this.k_ - n - 1; this.ds(t) } this.U_() } V_() { this.j_(), this.U_() } X_(t) { return !this.Sn.ignoreWhitespaceIndices || (this.S_.get(t) || !1) } G_(t) { const i = function* (t) { const i = Math.round(t), n = i < t; let s = 1; for (; ;)n ? (yield i + s, yield i - s) : (yield i - s, yield i + s), s++ }(t), n = this.F_(); for (; n;) { const t = i.next().value; if (this.S_.get(t)) return t; if (t < 0 || t > n) break } return t } } var ki, Pi, Ti, Ri, Di; !function (t) { t[t.OnTouchEnd = 0] = "OnTouchEnd", t[t.OnNextTap = 1] = "OnNextTap" }(ki || (ki = {})); class Ei { constructor(t, i, n) { this.Pu = [], this.Tu = [], this.so = 0, this.Ru = null, this.Du = new o, this.Eu = new o, this.Iu = null, this.Vu = t, this.Sn = i, this.qo = n, this.cl = new S(this.Sn.layout.colorParsers), this.Au = new M(this), this.uh = new yi(this, i.timeScale, this.Sn.localization, n), this.Ct = new j(this, i.crosshair), this.Bu = new Ut(i.crosshair), this.zu(0), this.Pu[0].po(2e3), this.Ou = this.Lu(0), this.Nu = this.Lu(1) } Vh() { this.Wu(Y.gs()) } ar() { this.Wu(Y.ws()) } Xh() { this.Wu(new Y(1)) } Ah(t) { const i = this.Fu(t); this.Wu(i) } Hu() { return this.Ru } Uu(t) { if (this.Ru?.Wo === t?.Wo && this.Ru?.Fo?.Zs === t?.Fo?.Zs) return; const i = this.Ru; this.Ru = t, null !== i && this.Ah(i.Wo), null !== t && t.Wo !== i?.Wo && this.Ah(t.Wo) } N() { return this.Sn } hr(t) { _(this.Sn, t), this.Pu.forEach((i => i.uo(t))), void 0 !== t.timeScale && this.uh.hr(t.timeScale), void 0 !== t.localization && this.uh.D_(t.localization), (t.leftPriceScale || t.rightPriceScale) && this.Du.p(), this.Ou = this.Lu(0), this.Nu = this.Lu(1), this.Vh() } $u(t, i, n = 0) { const s = this.Pu[n]; if (void 0 === s) return; if ("left" === t) return _(this.Sn, { leftPriceScale: i }), s.uo({ leftPriceScale: i }), this.Du.p(), void this.Vh(); if ("right" === t) return _(this.Sn, { rightPriceScale: i }), s.uo({ rightPriceScale: i }), this.Du.p(), void this.Vh(); const e = this.ju(t, n); null !== e && (e.Wt.hr(i), this.Du.p()) } ju(t, i) { const n = this.Pu[i]; if (void 0 === n) return null; const s = n.co(t); return null !== s ? { Fn: n, Wt: s } : null } At() { return this.uh } Hn() { return this.Pu } qu() { return this.Ct } Yu() { return this.Eu } Zu(t, i) { t.Cl(i), this.J_() } vo(t) { this.so = t, this.uh.vo(this.so), this.Pu.forEach((i => i.vo(t))), this.J_() } Ku(t) { 1 !== this.Pu.length && (r(t >= 0 && t < this.Pu.length, "Invalid pane index"), this.Pu.splice(t, 1), this.Vh()) } Xu(t, i) { if (this.Pu.length < 2) return; r(t >= 0 && t < this.Pu.length, "Invalid pane index"); const n = this.Pu[t], s = this.Pu.reduce(((t, i) => t + i.fo()), 0), e = this.Pu.reduce(((t, i) => t + i.$t()), 0), h = e - 30 * (this.Pu.length - 1); i = Math.min(h, Math.max(30, i)); const a = s / e, l = n.$t(); n.po(i * a); let o = i - l, _ = this.Pu.length - 1; for (const t of this.Pu) if (t !== n) { const i = Math.min(h, Math.max(30, t.$t() - o / _)); o -= t.$t() - i, _ -= 1; const n = i * a; t.po(n) } this.Vh() } Gu(t, i) { r(t >= 0 && t < this.Pu.length && i >= 0 && i < this.Pu.length, "Invalid pane index"); const n = this.Pu[t], s = this.Pu[i]; this.Pu[t] = s, this.Pu[i] = n, this.Vh() } ko(t, i, n) { t.ko(i, n) } Po(t, i, n) { t.Po(i, n), this.Bh(), this.Wu(this.Ju(t, 2)) } To(t, i) { t.To(i), this.Wu(this.Ju(t, 2)) } Ro(t, i, n) { i.wl() || t.Ro(i, n) } Do(t, i, n) { i.wl() || (t.Do(i, n), this.Bh(), this.Wu(this.Ju(t, 2))) } Eo(t, i) { i.wl() || (t.Eo(i), this.Wu(this.Ju(t, 2))) } Vo(t, i) { t.Vo(i), this.Wu(this.Ju(t, 2)) } Qu(t) { this.uh.Ul(t) } tc(t, i) { const n = this.At(); if (n.Zi() || 0 === i) return; const s = n.Qi(); t = Math.max(1, Math.min(t, s)), n.hu(t, i), this.J_() } nc(t) { this.sc(0), this.ec(t), this.rc() } hc(t) { this.uh.$l(t), this.J_() } ac() { this.uh.jl(), this.ar() } sc(t) { this.uh.ql(t) } ec(t) { this.uh.Yl(t), this.J_() } rc() { this.uh.Zl(), this.ar() } jn() { return this.Tu } lc(t, i, n, s, e) { this.Ct.Rn(t, i); let r = NaN, h = this.uh.Z_(t, !0); const a = this.uh.ye(); null !== a && (h = Math.min(Math.max(a.Uh(), h), a.bi())); const l = s.yn(), o = l.zt(); if (null !== o && (r = l.kn(i, o)), r = this.Bu.Ma(r, h, s), this.Ct.Vn(h, r, s), this.Xh(), !e) { const e = wi(s, t, i); this.Uu(e && { Wo: e.Wo, Fo: e.Fo, Uo: e.Uo || null }), this.Eu.p(this.Ct.Vt(), { x: t, y: i }, n) } } oc(t, i, n) { const s = n.yn(), e = s.zt(), r = s.Nt(t, a(e)), h = this.uh.A_(i, !0), l = this.uh.jt(a(h)); this.lc(l, r, null, n, !0) } _c(t) { this.qu().Bn(), this.Xh(), t || this.Eu.p(null, null, null) } Bh() { const t = this.Ct.Fn(); if (null !== t) { const i = this.Ct.En(), n = this.Ct.In(); this.lc(i, n, null, t) } this.Ct.On() } uc(t, i, n) { const s = this.uh.Pn(0); void 0 !== i && void 0 !== n && this.uh.kt(i, n); const e = this.uh.Pn(0), r = this.uh.q_(), h = this.uh.ye(); if (null !== h && null !== s && null !== e) { const i = h.Te(r), a = this.qo.key(s) > this.qo.key(e), l = null !== t && t > r && !a, o = this.uh.N().allowShiftVisibleRangeOnWhitespaceReplacement, _ = i && (!(void 0 === n) || o) && this.uh.N().shiftVisibleRangeOnNewBar; if (l && !_) { const i = t - r; this.uh.ds(this.uh.iu() - i) } } this.uh.ru(t) } Oh(t) { null !== t && t.Bo() } Hs(t) { if (function (t) { return t instanceof fi }(t)) return t; const i = this.Pu.find((i => i.Dt().includes(t))); return void 0 === i ? null : i } J_() { this.Pu.forEach((t => t.Bo())), this.Bh() } m() { this.Pu.forEach((t => t.m())), this.Pu.length = 0, this.Sn.localization.priceFormatter = void 0, this.Sn.localization.percentageFormatter = void 0, this.Sn.localization.timeFormatter = void 0 } cc() { return this.Au } qs() { return this.Au.N() } do() { return this.Du } dc(t, i) { const n = this.zu(i); this.fc(t, n), this.Tu.push(t), 1 === this.Tu.length ? this.Vh() : this.ar() } vc(t) { const i = this.Hs(t), n = this.Tu.indexOf(t); r(-1 !== n, "Series not found"); const s = a(i); this.Tu.splice(n, 1), s.Wl(t), t.m && t.m(), this.uh.R_(), this.mc(s) } Ih(t, i) { const n = a(this.Hs(t)); n.Wl(t), n.Ll(t, i, a(t.hn())) } mu() { const t = Y.ws(); t.ss(), this.Wu(t) } wc(t) { const i = Y.ws(); i.hs(t), this.Wu(i) } us() { const t = Y.ws(); t.us(), this.Wu(t) } cs(t) { const i = Y.ws(); i.cs(t), this.Wu(i) } ds(t) { const i = Y.ws(); i.ds(t), this.Wu(i) } ls(t) { const i = Y.ws(); i.ls(t), this.Wu(i) } es() { const t = Y.ws(); t.es(), this.Wu(t) } gc() { return this.Sn.rightPriceScale.visible ? "right" : "left" } Mc(t, i) { r(i >= 0, "Index should be greater or equal to 0"); if (i === this.bc(t)) return; const n = a(this.Hs(t)); n.Wl(t); const s = this.zu(i); this.fc(t, s), 0 === n.ba().length && this.mc(n) } xc() { return this.Nu } $() { return this.Ou } Ut(t) { const i = this.Nu, n = this.Ou; if (i === n) return i; if (t = Math.max(0, Math.min(100, Math.round(100 * t))), null === this.Iu || this.Iu.mr !== n || this.Iu.wr !== i) this.Iu = { mr: n, wr: i, Sc: new Map }; else { const i = this.Iu.Sc.get(t); if (void 0 !== i) return i } const s = this.cl.tt(n, i, t / 100); return this.Iu.Sc.set(t, s), s } Cc(t) { return this.Pu.indexOf(t) } Ki() { return this.cl } zu(t) { if (r(t >= 0, "Index should be greater or equal to 0"), (t = Math.min(this.Pu.length, t)) < this.Pu.length) return this.Pu[t]; const i = new fi(this.uh, this); this.Pu.push(i); const n = Y.gs(); return n.Gn(t, { Jn: 0, Qn: !0 }), this.Wu(n), i } bc(t) { return this.Pu.findIndex((i => i.wo().includes(t))) } Ju(t, i) { const n = new Y(i); if (null !== t) { const s = this.Pu.indexOf(t); n.Gn(s, { Jn: i }) } return n } Fu(t, i) { return void 0 === i && (i = 2), this.Ju(this.Hs(t), i) } Wu(t) { this.Vu && this.Vu(t), this.Pu.forEach((t => t.Oo().lr().kt())) } fc(t, i) { const n = t.N().priceScaleId, s = void 0 !== n ? n : this.gc(); i.Ll(t, s), q(s) || t.hr(t.N()) } Lu(t) { const i = this.Sn.layout; return "gradient" === i.background.type ? 0 === t ? i.background.topColor : i.background.bottomColor : i.background.color } mc(t) { 0 === t.ba().length && this.Pu.length > 1 && (this.Pu.splice(this.Cc(t), 1), this.Vh()) } } function Ii(t) { return !u(t) && !d(t) } function Vi(t) { return u(t) } !function (t) { t[t.Disabled = 0] = "Disabled", t[t.Continuous = 1] = "Continuous", t[t.OnDataUpdate = 2] = "OnDataUpdate" }(Pi || (Pi = {})), function (t) { t[t.LastBar = 0] = "LastBar", t[t.LastVisible = 1] = "LastVisible" }(Ti || (Ti = {})), function (t) { t.Solid = "solid", t.VerticalGradient = "gradient" }(Ri || (Ri = {})), function (t) { t[t.Year = 0] = "Year", t[t.Month = 1] = "Month", t[t.DayOfMonth = 2] = "DayOfMonth", t[t.Time = 3] = "Time", t[t.TimeWithSeconds = 4] = "TimeWithSeconds" }(Di || (Di = {})); const Ai = t => t.getUTCFullYear(); function Bi(t, i, n) { return i.replace(/yyyy/g, (t => K(Ai(t), 4))(t)).replace(/yy/g, (t => K(Ai(t) % 100, 2))(t)).replace(/MMMM/g, ((t, i) => new Date(t.getUTCFullYear(), t.getUTCMonth(), 1).toLocaleString(i, { month: "long" }))(t, n)).replace(/MMM/g, ((t, i) => new Date(t.getUTCFullYear(), t.getUTCMonth(), 1).toLocaleString(i, { month: "short" }))(t, n)).replace(/MM/g, (t => K((t => t.getUTCMonth() + 1)(t), 2))(t)).replace(/dd/g, (t => K((t => t.getUTCDate())(t), 2))(t)) } class zi { constructor(t = "yyyy-MM-dd", i = "default") { this.yc = t, this.kc = i } Yo(t) { return Bi(t, this.yc, this.kc) } } class Oi { constructor(t) { this.Pc = t || "%h:%m:%s" } Yo(t) { return this.Pc.replace("%h", K(t.getUTCHours(), 2)).replace("%m", K(t.getUTCMinutes(), 2)).replace("%s", K(t.getUTCSeconds(), 2)) } } const Li = { Tc: "yyyy-MM-dd", Rc: "%h:%m:%s", Dc: " ", Ec: "default" }; class Ni { constructor(t = {}) { const i = { ...Li, ...t }; this.Ic = new zi(i.Tc, i.Ec), this.Vc = new Oi(i.Rc), this.Ac = i.Dc } Yo(t) { return `${this.Ic.Yo(t)}${this.Ac}${this.Vc.Yo(t)}` } } function Wi(t) { return 60 * t * 60 * 1e3 } function Fi(t) { return 60 * t * 1e3 } const Hi = [{ Bc: (Ui = 1, 1e3 * Ui), zc: 10 }, { Bc: Fi(1), zc: 20 }, { Bc: Fi(5), zc: 21 }, { Bc: Fi(30), zc: 22 }, { Bc: Wi(1), zc: 30 }, { Bc: Wi(3), zc: 31 }, { Bc: Wi(6), zc: 32 }, { Bc: Wi(12), zc: 33 }]; var Ui; function $i(t, i) { if (t.getUTCFullYear() !== i.getUTCFullYear()) return 70; if (t.getUTCMonth() !== i.getUTCMonth()) return 60; if (t.getUTCDate() !== i.getUTCDate()) return 50; for (let n = Hi.length - 1; n >= 0; --n)if (Math.floor(i.getTime() / Hi[n].Bc) !== Math.floor(t.getTime() / Hi[n].Bc)) return Hi[n].zc; return 0 } function ji(t) { let i = t; if (d(t) && (i = Yi(t)), !Ii(i)) throw new Error("time must be of type BusinessDay"); const n = new Date(Date.UTC(i.year, i.month - 1, i.day, 0, 0, 0, 0)); return { Oc: Math.round(n.getTime() / 1e3), Lc: i } } function qi(t) { if (!Vi(t)) throw new Error("time must be of type isUTCTimestamp"); return { Oc: t } } function Yi(t) { const i = new Date(t); if (isNaN(i.getTime())) throw new Error(`Invalid date string=${t}, expected format=yyyy-mm-dd`); return { day: i.getUTCDate(), month: i.getUTCMonth() + 1, year: i.getUTCFullYear() } } function Zi(t) { d(t.time) && (t.time = Yi(t.time)) } class Ki { options() { return this.Sn } setOptions(t) { this.Sn = t, this.updateFormatter(t.localization) } preprocessData(t) { Array.isArray(t) ? function (t) { t.forEach(Zi) }(t) : Zi(t) } createConverterToInternalObj(t) { return a(function (t) { return 0 === t.length ? null : Ii(t[0].time) || d(t[0].time) ? ji : qi }(t)) } key(t) { return "object" == typeof t && "Oc" in t ? t.Oc : this.key(this.convertHorzItemToInternal(t)) } cacheKey(t) { const i = t; return void 0 === i.Lc ? new Date(1e3 * i.Oc).getTime() : new Date(Date.UTC(i.Lc.year, i.Lc.month - 1, i.Lc.day)).getTime() } convertHorzItemToInternal(t) { return Vi(i = t) ? qi(i) : Ii(i) ? ji(i) : ji(Yi(i)); var i } updateFormatter(t) { if (!this.Sn) return; const i = t.dateFormat; this.Sn.timeScale.timeVisible ? this.Nc = new Ni({ Tc: i, Rc: this.Sn.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m", Dc: "   ", Ec: t.locale }) : this.Nc = new zi(i, t.locale) } formatHorzItem(t) { const i = t; return this.Nc.Yo(new Date(1e3 * i.Oc)) } formatTickmark(t, i) { const n = function (t, i, n) { switch (t) { case 0: case 10: return i ? n ? 4 : 3 : 2; case 20: case 21: case 22: case 30: case 31: case 32: case 33: return i ? 3 : 2; case 50: return 2; case 60: return 1; case 70: return 0 } }(t.weight, this.Sn.timeScale.timeVisible, this.Sn.timeScale.secondsVisible), s = this.Sn.timeScale; if (void 0 !== s.tickMarkFormatter) { const e = s.tickMarkFormatter(t.originalTime, n, i.locale); if (null !== e) return e } return function (t, i, n) { const s = {}; switch (i) { case 0: s.year = "numeric"; break; case 1: s.month = "short"; break; case 2: s.day = "numeric"; break; case 3: s.hour12 = !1, s.hour = "2-digit", s.minute = "2-digit"; break; case 4: s.hour12 = !1, s.hour = "2-digit", s.minute = "2-digit", s.second = "2-digit" }const e = void 0 === t.Lc ? new Date(1e3 * t.Oc) : new Date(Date.UTC(t.Lc.year, t.Lc.month - 1, t.Lc.day)); return new Date(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()).toLocaleString(n, s) }(t.time, n, i.locale) } maxTickMarkWeight(t) { let i = t.reduce(Ci, t[0]).weight; return i > 30 && i < 50 && (i = 30), i } fillWeightsForPoints(t, i) { !function (t, i = 0) { if (0 === t.length) return; let n = 0 === i ? null : t[i - 1].time.Oc, s = null !== n ? new Date(1e3 * n) : null, e = 0; for (let r = i; r < t.length; ++r) { const i = t[r], h = new Date(1e3 * i.time.Oc); null !== s && (i.timeWeight = $i(h, s)), e += i.time.Oc - (n || i.time.Oc), n = i.time.Oc, s = h } if (0 === i && t.length > 1) { const i = Math.ceil(e / (t.length - 1)), n = new Date(1e3 * (t[0].time.Oc - i)); t[0].timeWeight = $i(new Date(1e3 * t[0].time.Oc), n) } }(t, i) } static Wc(t) { return _({ localization: { dateFormat: "dd MMM 'yy" } }, t ?? {}) } } function Xi(t) { var i = t.width, n = t.height; if (i < 0) throw new Error("Negative width is not allowed for Size"); if (n < 0) throw new Error("Negative height is not allowed for Size"); return { width: i, height: n } } function Gi(t, i) { return t.width === i.width && t.height === i.height } var Ji = function () { function t(t) { var i = this; this._resolutionListener = function () { return i._onResolutionChanged() }, this._resolutionMediaQueryList = null, this._observers = [], this._window = t, this._installResolutionListener() } return t.prototype.dispose = function () { this._uninstallResolutionListener(), this._window = null }, Object.defineProperty(t.prototype, "value", { get: function () { return this._window.devicePixelRatio }, enumerable: !1, configurable: !0 }), t.prototype.subscribe = function (t) { var i = this, n = { next: t }; return this._observers.push(n), { unsubscribe: function () { i._observers = i._observers.filter((function (t) { return t !== n })) } } }, t.prototype._installResolutionListener = function () { if (null !== this._resolutionMediaQueryList) throw new Error("Resolution listener is already installed"); var t = this._window.devicePixelRatio; this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(t, "dppx)")), this._resolutionMediaQueryList.addListener(this._resolutionListener) }, t.prototype._uninstallResolutionListener = function () { null !== this._resolutionMediaQueryList && (this._resolutionMediaQueryList.removeListener(this._resolutionListener), this._resolutionMediaQueryList = null) }, t.prototype._reinstallResolutionListener = function () { this._uninstallResolutionListener(), this._installResolutionListener() }, t.prototype._onResolutionChanged = function () { var t = this; this._observers.forEach((function (i) { return i.next(t._window.devicePixelRatio) })), this._reinstallResolutionListener() }, t }(); var Qi = function () { function t(t, i, n) { var s; this._canvasElement = null, this._bitmapSizeChangedListeners = [], this._suggestedBitmapSize = null, this._suggestedBitmapSizeChangedListeners = [], this._devicePixelRatioObservable = null, this._canvasElementResizeObserver = null, this._canvasElement = t, this._canvasElementClientSize = Xi({ width: this._canvasElement.clientWidth, height: this._canvasElement.clientHeight }), this._transformBitmapSize = null != i ? i : function (t) { return t }, this._allowResizeObserver = null === (s = null == n ? void 0 : n.allowResizeObserver) || void 0 === s || s, this._chooseAndInitObserver() } return t.prototype.dispose = function () { var t, i; if (null === this._canvasElement) throw new Error("Object is disposed"); null === (t = this._canvasElementResizeObserver) || void 0 === t || t.disconnect(), this._canvasElementResizeObserver = null, null === (i = this._devicePixelRatioObservable) || void 0 === i || i.dispose(), this._devicePixelRatioObservable = null, this._suggestedBitmapSizeChangedListeners.length = 0, this._bitmapSizeChangedListeners.length = 0, this._canvasElement = null }, Object.defineProperty(t.prototype, "canvasElement", { get: function () { if (null === this._canvasElement) throw new Error("Object is disposed"); return this._canvasElement }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "canvasElementClientSize", { get: function () { return this._canvasElementClientSize }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bitmapSize", { get: function () { return Xi({ width: this.canvasElement.width, height: this.canvasElement.height }) }, enumerable: !1, configurable: !0 }), t.prototype.resizeCanvasElement = function (t) { this._canvasElementClientSize = Xi(t), this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px"), this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px"), this._invalidateBitmapSize() }, t.prototype.subscribeBitmapSizeChanged = function (t) { this._bitmapSizeChangedListeners.push(t) }, t.prototype.unsubscribeBitmapSizeChanged = function (t) { this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter((function (i) { return i !== t })) }, Object.defineProperty(t.prototype, "suggestedBitmapSize", { get: function () { return this._suggestedBitmapSize }, enumerable: !1, configurable: !0 }), t.prototype.subscribeSuggestedBitmapSizeChanged = function (t) { this._suggestedBitmapSizeChangedListeners.push(t) }, t.prototype.unsubscribeSuggestedBitmapSizeChanged = function (t) { this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter((function (i) { return i !== t })) }, t.prototype.applySuggestedBitmapSize = function () { if (null !== this._suggestedBitmapSize) { var t = this._suggestedBitmapSize; this._suggestedBitmapSize = null, this._resizeBitmap(t), this._emitSuggestedBitmapSizeChanged(t, this._suggestedBitmapSize) } }, t.prototype._resizeBitmap = function (t) { var i = this.bitmapSize; Gi(i, t) || (this.canvasElement.width = t.width, this.canvasElement.height = t.height, this._emitBitmapSizeChanged(i, t)) }, t.prototype._emitBitmapSizeChanged = function (t, i) { var n = this; this._bitmapSizeChangedListeners.forEach((function (s) { return s.call(n, t, i) })) }, t.prototype._suggestNewBitmapSize = function (t) { var i = this._suggestedBitmapSize, n = Xi(this._transformBitmapSize(t, this._canvasElementClientSize)), s = Gi(this.bitmapSize, n) ? null : n; null === i && null === s || null !== i && null !== s && Gi(i, s) || (this._suggestedBitmapSize = s, this._emitSuggestedBitmapSizeChanged(i, s)) }, t.prototype._emitSuggestedBitmapSizeChanged = function (t, i) { var n = this; this._suggestedBitmapSizeChangedListeners.forEach((function (s) { return s.call(n, t, i) })) }, t.prototype._chooseAndInitObserver = function () { var t = this; this._allowResizeObserver ? new Promise((function (t) { var i = new ResizeObserver((function (n) { t(n.every((function (t) { return "devicePixelContentBoxSize" in t }))), i.disconnect() })); i.observe(document.body, { box: "device-pixel-content-box" }) })).catch((function () { return !1 })).then((function (i) { return i ? t._initResizeObserver() : t._initDevicePixelRatioObservable() })) : this._initDevicePixelRatioObservable() }, t.prototype._initDevicePixelRatioObservable = function () { var t = this; if (null !== this._canvasElement) { var i = tn(this._canvasElement); if (null === i) throw new Error("No window is associated with the canvas"); this._devicePixelRatioObservable = function (t) { return new Ji(t) }(i), this._devicePixelRatioObservable.subscribe((function () { return t._invalidateBitmapSize() })), this._invalidateBitmapSize() } }, t.prototype._invalidateBitmapSize = function () { var t, i; if (null !== this._canvasElement) { var n = tn(this._canvasElement); if (null !== n) { var s = null !== (i = null === (t = this._devicePixelRatioObservable) || void 0 === t ? void 0 : t.value) && void 0 !== i ? i : n.devicePixelRatio, e = this._canvasElement.getClientRects(), r = void 0 !== e[0] ? function (t, i) { return Xi({ width: Math.round(t.left * i + t.width * i) - Math.round(t.left * i), height: Math.round(t.top * i + t.height * i) - Math.round(t.top * i) }) }(e[0], s) : Xi({ width: this._canvasElementClientSize.width * s, height: this._canvasElementClientSize.height * s }); this._suggestNewBitmapSize(r) } } }, t.prototype._initResizeObserver = function () { var t = this; null !== this._canvasElement && (this._canvasElementResizeObserver = new ResizeObserver((function (i) { var n = i.find((function (i) { return i.target === t._canvasElement })); if (n && n.devicePixelContentBoxSize && n.devicePixelContentBoxSize[0]) { var s = n.devicePixelContentBoxSize[0], e = Xi({ width: s.inlineSize, height: s.blockSize }); t._suggestNewBitmapSize(e) } })), this._canvasElementResizeObserver.observe(this._canvasElement, { box: "device-pixel-content-box" })) }, t }(); function tn(t) { return t.ownerDocument.defaultView } var nn = function () { function t(t, i, n) { if (0 === i.width || 0 === i.height) throw new TypeError("Rendering target could only be created on a media with positive width and height"); if (this._mediaSize = i, 0 === n.width || 0 === n.height) throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height"); this._bitmapSize = n, this._context = t } return t.prototype.useMediaCoordinateSpace = function (t) { try { return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio), t({ context: this._context, mediaSize: this._mediaSize }) } finally { this._context.restore() } }, t.prototype.useBitmapCoordinateSpace = function (t) { try { return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), t({ context: this._context, mediaSize: this._mediaSize, bitmapSize: this._bitmapSize, horizontalPixelRatio: this._horizontalPixelRatio, verticalPixelRatio: this._verticalPixelRatio }) } finally { this._context.restore() } }, Object.defineProperty(t.prototype, "_horizontalPixelRatio", { get: function () { return this._bitmapSize.width / this._mediaSize.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "_verticalPixelRatio", { get: function () { return this._bitmapSize.height / this._mediaSize.height }, enumerable: !1, configurable: !0 }), t }(); function sn(t, i) { var n = t.canvasElementClientSize; if (0 === n.width || 0 === n.height) return null; var s = t.bitmapSize; if (0 === s.width || 0 === s.height) return null; var e = t.canvasElement.getContext("2d", i); return null === e ? null : new nn(e, n, s) } const en = "undefined" != typeof window; function rn() { return !!en && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1 } function hn() { return !!en && /iPhone|iPad|iPod/.test(window.navigator.platform) } function an(t) { return t + t % 2 } function ln(t) { en && void 0 !== window.chrome && t.addEventListener("mousedown", (t => { if (1 === t.button) return t.preventDefault(), !1 })) } class on { constructor(t, i, n) { this.Fc = 0, this.Hc = null, this.Uc = { _t: Number.NEGATIVE_INFINITY, ut: Number.POSITIVE_INFINITY }, this.$c = 0, this.jc = null, this.qc = { _t: Number.NEGATIVE_INFINITY, ut: Number.POSITIVE_INFINITY }, this.Yc = null, this.Zc = !1, this.Kc = null, this.Xc = null, this.Gc = !1, this.Jc = !1, this.Qc = !1, this.td = null, this.nd = null, this.sd = null, this.ed = null, this.rd = null, this.hd = null, this.ad = null, this.ld = 0, this.od = !1, this._d = !1, this.ud = !1, this.dd = 0, this.fd = null, this.pd = !hn(), this.vd = t => { this.md(t) }, this.wd = t => { if (this.gd(t)) { const i = this.Md(t); if (++this.$c, this.jc && this.$c > 1) { const { bd: n } = this.xd(cn(t), this.qc); n < 30 && !this.Qc && this.Sd(i, this.yd.Cd), this.kd() } } else { const i = this.Md(t); if (++this.Fc, this.Hc && this.Fc > 1) { const { bd: n } = this.xd(cn(t), this.Uc); n < 5 && !this.Jc && this.Pd(i, this.yd.Td), this.Rd() } } }, this.Dd = t, this.yd = i, this.Sn = n, this.Ed() } m() { null !== this.td && (this.td(), this.td = null), null !== this.nd && (this.nd(), this.nd = null), null !== this.ed && (this.ed(), this.ed = null), null !== this.rd && (this.rd(), this.rd = null), null !== this.hd && (this.hd(), this.hd = null), null !== this.sd && (this.sd(), this.sd = null), this.Id(), this.Rd() } Vd(t) { this.ed && this.ed(); const i = this.Ad.bind(this); if (this.ed = () => { this.Dd.removeEventListener("mousemove", i) }, this.Dd.addEventListener("mousemove", i), this.gd(t)) return; const n = this.Md(t); this.Pd(n, this.yd.Bd), this.pd = !0 } Rd() { null !== this.Hc && clearTimeout(this.Hc), this.Fc = 0, this.Hc = null, this.Uc = { _t: Number.NEGATIVE_INFINITY, ut: Number.POSITIVE_INFINITY } } kd() { null !== this.jc && clearTimeout(this.jc), this.$c = 0, this.jc = null, this.qc = { _t: Number.NEGATIVE_INFINITY, ut: Number.POSITIVE_INFINITY } } Ad(t) { if (this.ud || null !== this.Xc) return; if (this.gd(t)) return; const i = this.Md(t); this.Pd(i, this.yd.zd), this.pd = !0 } Od(t) { const i = fn(t.changedTouches, a(this.fd)); if (null === i) return; if (this.dd = dn(t), null !== this.ad) return; if (this._d) return; this.od = !0; const n = this.xd(cn(i), a(this.Xc)), { Ld: s, Nd: e, bd: r } = n; if (this.Gc || !(r < 5)) { if (!this.Gc) { const t = .5 * s, i = e >= t && !this.Sn.Wd(), n = t > e && !this.Sn.Fd(); i || n || (this._d = !0), this.Gc = !0, this.Qc = !0, this.Id(), this.kd() } if (!this._d) { const n = this.Md(t, i); this.Sd(n, this.yd.Hd), un(t) } } } Ud(t) { if (0 !== t.button) return; const i = this.xd(cn(t), a(this.Kc)), { bd: n } = i; if (n >= 5 && (this.Jc = !0, this.Rd()), this.Jc) { const i = this.Md(t); this.Pd(i, this.yd.$d) } } xd(t, i) { const n = Math.abs(i._t - t._t), s = Math.abs(i.ut - t.ut); return { Ld: n, Nd: s, bd: n + s } } jd(t) { let i = fn(t.changedTouches, a(this.fd)); if (null === i && 0 === t.touches.length && (i = t.changedTouches[0]), null === i) return; this.fd = null, this.dd = dn(t), this.Id(), this.Xc = null, this.hd && (this.hd(), this.hd = null); const n = this.Md(t, i); if (this.Sd(n, this.yd.qd), ++this.$c, this.jc && this.$c > 1) { const { bd: t } = this.xd(cn(i), this.qc); t < 30 && !this.Qc && this.Sd(n, this.yd.Cd), this.kd() } else this.Qc || (this.Sd(n, this.yd.Yd), this.yd.Yd && un(t)); 0 === this.$c && un(t), 0 === t.touches.length && this.Zc && (this.Zc = !1, un(t)) } md(t) { if (0 !== t.button) return; const i = this.Md(t); if (this.Kc = null, this.ud = !1, this.rd && (this.rd(), this.rd = null), rn()) { this.Dd.ownerDocument.documentElement.removeEventListener("mouseleave", this.vd) } if (!this.gd(t)) if (this.Pd(i, this.yd.Zd), ++this.Fc, this.Hc && this.Fc > 1) { const { bd: n } = this.xd(cn(t), this.Uc); n < 5 && !this.Jc && this.Pd(i, this.yd.Td), this.Rd() } else this.Jc || this.Pd(i, this.yd.Kd) } Id() { null !== this.Yc && (clearTimeout(this.Yc), this.Yc = null) } Xd(t) { if (null !== this.fd) return; const i = t.changedTouches[0]; this.fd = i.identifier, this.dd = dn(t); const n = this.Dd.ownerDocument.documentElement; this.Qc = !1, this.Gc = !1, this._d = !1, this.Xc = cn(i), this.hd && (this.hd(), this.hd = null); { const i = this.Od.bind(this), s = this.jd.bind(this); this.hd = () => { n.removeEventListener("touchmove", i), n.removeEventListener("touchend", s) }, n.addEventListener("touchmove", i, { passive: !1 }), n.addEventListener("touchend", s, { passive: !1 }), this.Id(), this.Yc = setTimeout(this.Gd.bind(this, t), 240) } const s = this.Md(t, i); this.Sd(s, this.yd.Jd), this.jc || (this.$c = 0, this.jc = setTimeout(this.kd.bind(this), 500), this.qc = cn(i)) } Qd(t) { if (0 !== t.button) return; const i = this.Dd.ownerDocument.documentElement; rn() && i.addEventListener("mouseleave", this.vd), this.Jc = !1, this.Kc = cn(t), this.rd && (this.rd(), this.rd = null); { const t = this.Ud.bind(this), n = this.md.bind(this); this.rd = () => { i.removeEventListener("mousemove", t), i.removeEventListener("mouseup", n) }, i.addEventListener("mousemove", t), i.addEventListener("mouseup", n) } if (this.ud = !0, this.gd(t)) return; const n = this.Md(t); this.Pd(n, this.yd.tf), this.Hc || (this.Fc = 0, this.Hc = setTimeout(this.Rd.bind(this), 500), this.Uc = cn(t)) } Ed() { this.Dd.addEventListener("mouseenter", this.Vd.bind(this)), this.Dd.addEventListener("touchcancel", this.Id.bind(this)); { const t = this.Dd.ownerDocument, i = t => { this.yd.if && (t.composed && this.Dd.contains(t.composedPath()[0]) || t.target && this.Dd.contains(t.target) || this.yd.if()) }; this.nd = () => { t.removeEventListener("touchstart", i) }, this.td = () => { t.removeEventListener("mousedown", i) }, t.addEventListener("mousedown", i), t.addEventListener("touchstart", i, { passive: !0 }) } hn() && (this.sd = () => { this.Dd.removeEventListener("dblclick", this.wd) }, this.Dd.addEventListener("dblclick", this.wd)), this.Dd.addEventListener("mouseleave", this.nf.bind(this)), this.Dd.addEventListener("touchstart", this.Xd.bind(this), { passive: !0 }), ln(this.Dd), this.Dd.addEventListener("mousedown", this.Qd.bind(this)), this.sf(), this.Dd.addEventListener("touchmove", (() => { }), { passive: !1 }) } sf() { void 0 === this.yd.ef && void 0 === this.yd.rf && void 0 === this.yd.hf || (this.Dd.addEventListener("touchstart", (t => this.af(t.touches)), { passive: !0 }), this.Dd.addEventListener("touchmove", (t => { if (2 === t.touches.length && null !== this.ad && void 0 !== this.yd.rf) { const i = _n(t.touches[0], t.touches[1]) / this.ld; this.yd.rf(this.ad, i), un(t) } }), { passive: !1 }), this.Dd.addEventListener("touchend", (t => { this.af(t.touches) }))) } af(t) { 1 === t.length && (this.od = !1), 2 !== t.length || this.od || this.Zc ? this.lf() : this._f(t) } _f(t) { const i = this.Dd.getBoundingClientRect() || { left: 0, top: 0 }; this.ad = { _t: (t[0].clientX - i.left + (t[1].clientX - i.left)) / 2, ut: (t[0].clientY - i.top + (t[1].clientY - i.top)) / 2 }, this.ld = _n(t[0], t[1]), void 0 !== this.yd.ef && this.yd.ef(), this.Id() } lf() { null !== this.ad && (this.ad = null, void 0 !== this.yd.hf && this.yd.hf()) } nf(t) { if (this.ed && this.ed(), this.gd(t)) return; if (!this.pd) return; const i = this.Md(t); this.Pd(i, this.yd.uf), this.pd = !hn() } Gd(t) { const i = fn(t.touches, a(this.fd)); if (null === i) return; const n = this.Md(t, i); this.Sd(n, this.yd.cf), this.Qc = !0, this.Zc = !0 } gd(t) { return t.sourceCapabilities && void 0 !== t.sourceCapabilities.firesTouchEvents ? t.sourceCapabilities.firesTouchEvents : dn(t) < this.dd + 500 } Sd(t, i) { i && i.call(this.yd, t) } Pd(t, i) { i && i.call(this.yd, t) } Md(t, i) { const n = i || t, s = this.Dd.getBoundingClientRect() || { left: 0, top: 0 }; return { clientX: n.clientX, clientY: n.clientY, pageX: n.pageX, pageY: n.pageY, screenX: n.screenX, screenY: n.screenY, localX: n.clientX - s.left, localY: n.clientY - s.top, ctrlKey: t.ctrlKey, altKey: t.altKey, shiftKey: t.shiftKey, metaKey: t.metaKey, df: !t.type.startsWith("mouse") && "contextmenu" !== t.type && "click" !== t.type, ff: t.type, pf: n.target, $o: t.view, vf: () => { "touchstart" !== t.type && un(t) } } } } function _n(t, i) { const n = t.clientX - i.clientX, s = t.clientY - i.clientY; return Math.sqrt(n * n + s * s) } function un(t) { t.cancelable && t.preventDefault() } function cn(t) { return { _t: t.pageX, ut: t.pageY } } function dn(t) { return t.timeStamp || performance.now() } function fn(t, i) { for (let n = 0; n < t.length; ++n)if (t[n].identifier === i) return t[n]; return null } class pn { constructor(t, i, n) { this.mf = null, this.wf = null, this.gf = !0, this.Mf = null, this.bf = t, this.xf = t.Sf()[i], this.Cf = t.Sf()[n], this.yf = document.createElement("tr"), this.yf.style.height = "1px", this.kf = document.createElement("td"), this.kf.style.position = "relative", this.kf.style.padding = "0", this.kf.style.margin = "0", this.kf.setAttribute("colspan", "3"), this.Pf(), this.yf.appendChild(this.kf), this.gf = this.bf.N().layout.panes.enableResize, this.gf ? this.Tf() : (this.mf = null, this.wf = null) } m() { null !== this.wf && this.wf.m() } Rf() { return this.yf } Df() { return Xi({ width: this.xf.Df().width, height: 1 }) } Ef() { return Xi({ width: this.xf.Ef().width, height: 1 * window.devicePixelRatio }) } If(t, i, n) { const s = this.Ef(); t.fillStyle = this.bf.N().layout.panes.separatorColor, t.fillRect(i, n, s.width, s.height) } kt() { this.Pf(), this.bf.N().layout.panes.enableResize !== this.gf && (this.gf = this.bf.N().layout.panes.enableResize, this.gf ? this.Tf() : (null !== this.mf && (this.kf.removeChild(this.mf.Vf), this.kf.removeChild(this.mf.Af), this.mf = null), null !== this.wf && (this.wf.m(), this.wf = null))) } Tf() { const t = document.createElement("div"), i = t.style; i.position = "fixed", i.display = "none", i.zIndex = "49", i.top = "0", i.left = "0", i.width = "100%", i.height = "100%", i.cursor = "row-resize", this.kf.appendChild(t); const n = document.createElement("div"), s = n.style; s.position = "absolute", s.zIndex = "50", s.top = "-4px", s.height = "9px", s.width = "100%", s.backgroundColor = "", s.cursor = "row-resize", this.kf.appendChild(n); const e = { Bd: this.Bf.bind(this), uf: this.zf.bind(this), tf: this.Of.bind(this), Jd: this.Of.bind(this), $d: this.Lf.bind(this), Hd: this.Lf.bind(this), Zd: this.Nf.bind(this), qd: this.Nf.bind(this) }; this.wf = new on(n, e, { Wd: () => !1, Fd: () => !0 }), this.mf = { Af: n, Vf: t } } Pf() { this.kf.style.background = this.bf.N().layout.panes.separatorColor } Bf(t) { null !== this.mf && (this.mf.Af.style.backgroundColor = this.bf.N().layout.panes.separatorHoverColor) } zf(t) { null !== this.mf && null === this.Mf && (this.mf.Af.style.backgroundColor = "") } Of(t) { if (null === this.mf) return; const i = this.xf.Wf().fo() + this.Cf.Wf().fo(), n = i / (this.xf.Df().height + this.Cf.Df().height), s = 30 * n; i <= 2 * s || (this.Mf = { Ff: t.pageY, Hf: this.xf.Wf().fo(), Uf: i - s, $f: i, jf: n, qf: s }, this.mf.Vf.style.display = "block") } Lf(t) { const i = this.Mf; if (null === i) return; const n = (t.pageY - i.Ff) * i.jf, s = si(i.Hf + n, i.qf, i.Uf); this.xf.Wf().po(s), this.Cf.Wf().po(i.$f - s), this.bf.Qt().Vh() } Nf(t) { null !== this.Mf && null !== this.mf && (this.Mf = null, this.mf.Vf.style.display = "none") } } function vn(t, i) { return t.Yf - i.Yf } function mn(t, i, n) { const s = (t.Yf - i.Yf) / (t.wt - i.wt); return Math.sign(s) * Math.min(Math.abs(s), n) } class wn { constructor(t, i, n, s) { this.Zf = null, this.Kf = null, this.Xf = null, this.Gf = null, this.Jf = null, this.Qf = 0, this.tp = 0, this.ip = t, this.np = i, this.sp = n, this.Ms = s } ep(t, i) { if (null !== this.Zf) { if (this.Zf.wt === i) return void (this.Zf.Yf = t); if (Math.abs(this.Zf.Yf - t) < this.Ms) return } this.Gf = this.Xf, this.Xf = this.Kf, this.Kf = this.Zf, this.Zf = { wt: i, Yf: t } } le(t, i) { if (null === this.Zf || null === this.Kf) return; if (i - this.Zf.wt > 50) return; let n = 0; const s = mn(this.Zf, this.Kf, this.np), e = vn(this.Zf, this.Kf), r = [s], h = [e]; if (n += e, null !== this.Xf) { const t = mn(this.Kf, this.Xf, this.np); if (Math.sign(t) === Math.sign(s)) { const i = vn(this.Kf, this.Xf); if (r.push(t), h.push(i), n += i, null !== this.Gf) { const t = mn(this.Xf, this.Gf, this.np); if (Math.sign(t) === Math.sign(s)) { const i = vn(this.Xf, this.Gf); r.push(t), h.push(i), n += i } } } } let a = 0; for (let t = 0; t < r.length; ++t)a += h[t] / n * r[t]; Math.abs(a) < this.ip || (this.Jf = { Yf: t, wt: i }, this.tp = a, this.Qf = function (t, i) { const n = Math.log(i); return Math.log(1 * n / -t) / n }(Math.abs(a), this.sp)) } cu(t) { const i = a(this.Jf), n = t - i.wt; return i.Yf + this.tp * (Math.pow(this.sp, n) - 1) / Math.log(this.sp) } uu(t) { return null === this.Jf || this.rp(t) === this.Qf } rp(t) { const i = t - a(this.Jf).wt; return Math.min(i, this.Qf) } } class gn { constructor(t, i) { this.hp = void 0, this.ap = void 0, this.lp = void 0, this.fn = !1, this.op = t, this._p = i, this.up() } kt() { this.up() } cp() { this.hp && this.op.removeChild(this.hp), this.ap && this.op.removeChild(this.ap), this.hp = void 0, this.ap = void 0 } dp() { return this.fn !== this.fp() || this.lp !== this.pp() } pp() { return this._p.Qt().Ki().J(this._p.N().layout.textColor) > 160 ? "dark" : "light" } fp() { return this._p.N().layout.attributionLogo } vp() { const t = new URL(location.href); return t.hostname ? "&utm_source=" + t.hostname + t.pathname : "" } up() { this.dp() && (this.cp(), this.fn = this.fp(), this.fn && (this.lp = this.pp(), this.ap = document.createElement("style"), this.ap.innerText = "a#tv-attr-logo{--fill:#131722;--stroke:#fff;position:absolute;left:10px;bottom:10px;height:19px;width:35px;margin:0;padding:0;border:0;z-index:3;}a#tv-attr-logo[data-dark]{--fill:#D1D4DC;--stroke:#131722;}", this.hp = document.createElement("a"), this.hp.href = `https://www.tradingview.com/?utm_medium=lwc-link&utm_campaign=lwc-chart${this.vp()}`, this.hp.title = "Charting by TradingView", this.hp.id = "tv-attr-logo", this.hp.target = "_blank", this.hp.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="35" height="19" fill="none"><g fill-rule="evenodd" clip-path="url(#a)" clip-rule="evenodd"><path fill="var(--stroke)" d="M2 0H0v10h6v9h21.4l.5-1.3 6-15 1-2.7H23.7l-.5 1.3-.2.6a5 5 0 0 0-7-.9V0H2Zm20 17h4l5.2-13 .8-2h-7l-1 2.5-.2.5-1.5 3.8-.3.7V17Zm-.8-10a3 3 0 0 0 .7-2.7A3 3 0 1 0 16.8 7h4.4ZM14 7V2H2v6h6v9h4V7h2Z"/><path fill="var(--fill)" d="M14 2H2v6h6v9h6V2Zm12 15h-7l6-15h7l-6 15Zm-7-9a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/></g><defs><clipPath id="a"><path fill="var(--stroke)" d="M0 0h35v19H0z"/></clipPath></defs></svg>', this.hp.toggleAttribute("data-dark", "dark" === this.lp), this.op.appendChild(this.ap), this.op.appendChild(this.hp))) } } function Mn(t, i) { const n = a(t.ownerDocument).createElement("canvas"); t.appendChild(n); const s = function (t, i) { if ("device-pixel-content-box" === i.type) return new Qi(t, i.transform, i.options); throw new Error("Unsupported binding target") }(n, { type: "device-pixel-content-box", options: { allowResizeObserver: !0 }, transform: (t, i) => ({ width: Math.max(t.width, i.width), height: Math.max(t.height, i.height) }) }); return s.resizeCanvasElement(i), s } function bn(t) { t.width = 1, t.height = 1, t.getContext("2d")?.clearRect(0, 0, 1, 1) } function xn(t, i, n, s) { t.ih && t.ih(i, n, s) } function Sn(t, i, n, s) { t.st(i, n, s) } function Cn(t, i, n, s) { const e = t(n, s); for (const t of e) { const n = t.Tt(s); null !== n && i(n) } } function yn(t, i) { return n => { if (!function (t) { return void 0 !== t.Wt }(n)) return []; return (n.Wt()?.wa() ?? "") !== i ? [] : n.ta?.(t) ?? [] } } function kn(t, i, n, s) { if (!t.length) return; let e = 0; const r = t[0].$t(s, !0); let h = 1 === i ? n / 2 - (t[0].Wi() - r / 2) : t[0].Wi() - r / 2 - n / 2; h = Math.max(0, h); for (let r = 1; r < t.length; r++) { const a = t[r], l = t[r - 1], o = l.$t(s, !1), _ = a.Wi(), u = l.Wi(); if (1 === i ? _ > u - o : _ < u + o) { const s = u - o * i; a.Fi(s); const r = s - i * o / 2; if ((1 === i ? r < 0 : r > n) && h > 0) { const s = 1 === i ? -1 - r : r - n, a = Math.min(s, h); for (let n = e; n < t.length; n++)t[n].Fi(t[n].Wi() + i * a); h -= a } } else e = r, h = 1 === i ? u - o - _ : _ - (u + o) } } class Pn { constructor(t, i, n, s) { this.qi = null, this.mp = null, this.wp = !1, this.gp = new tt(200), this.Mp = null, this.bp = 0, this.xp = !1, this.Sp = () => { this.xp || this.yt.Cp().Qt().ar() }, this.yp = () => { this.xp || this.yt.Cp().Qt().ar() }, this.yt = t, this.Sn = i, this._l = i.layout, this.Au = n, this.kp = "left" === s, this.Pp = yn("normal", s), this.Tp = yn("top", s), this.Rp = yn("bottom", s), this.kf = document.createElement("div"), this.kf.style.height = "100%", this.kf.style.overflow = "hidden", this.kf.style.width = "25px", this.kf.style.left = "0", this.kf.style.position = "relative", this.Dp = Mn(this.kf, Xi({ width: 16, height: 16 })), this.Dp.subscribeSuggestedBitmapSizeChanged(this.Sp); const e = this.Dp.canvasElement; e.style.position = "absolute", e.style.zIndex = "1", e.style.left = "0", e.style.top = "0", this.Ep = Mn(this.kf, Xi({ width: 16, height: 16 })), this.Ep.subscribeSuggestedBitmapSizeChanged(this.yp); const r = this.Ep.canvasElement; r.style.position = "absolute", r.style.zIndex = "2", r.style.left = "0", r.style.top = "0"; const h = { tf: this.Of.bind(this), Jd: this.Of.bind(this), $d: this.Lf.bind(this), Hd: this.Lf.bind(this), if: this.Ip.bind(this), Zd: this.Nf.bind(this), qd: this.Nf.bind(this), Td: this.Vp.bind(this), Cd: this.Vp.bind(this), Bd: this.Ap.bind(this), uf: this.zf.bind(this) }; this.wf = new on(this.Ep.canvasElement, h, { Wd: () => !this.Sn.handleScroll.vertTouchDrag, Fd: () => !0 }) } m() { this.wf.m(), this.Ep.unsubscribeSuggestedBitmapSizeChanged(this.yp), bn(this.Ep.canvasElement), this.Ep.dispose(), this.Dp.unsubscribeSuggestedBitmapSizeChanged(this.Sp), bn(this.Dp.canvasElement), this.Dp.dispose(), null !== this.qi && this.qi.Hl().u(this), this.qi = null } Rf() { return this.kf } k() { return this._l.fontSize } Bp() { const t = this.Au.N(); return this.Mp !== t.P && (this.gp.Is(), this.Mp = t.P), t } zp() { if (null === this.qi) return 0; let t = 0; const i = this.Bp(), n = a(this.Dp.canvasElement.getContext("2d", { colorSpace: this.yt.Cp().N().layout.colorSpace })); n.save(); const s = this.qi.Ea(); n.font = this.Op(), s.length > 0 && (t = Math.max(this.gp.Ei(n, s[0].$a), this.gp.Ei(n, s[s.length - 1].$a))); const e = this.Lp(); for (let i = e.length; i--;) { const s = this.gp.Ei(n, e[i].ri()); s > t && (t = s) } const r = this.qi.zt(); if (null !== r && null !== this.mp && (2 !== (h = this.Sn.crosshair).mode && h.horzLine.visible && h.horzLine.labelVisible)) { const i = this.qi.kn(1, r), s = this.qi.kn(this.mp.height - 2, r); t = Math.max(t, this.gp.Ei(n, this.qi.Xi(Math.floor(Math.min(i, s)) + .11111111111111, r)), this.gp.Ei(n, this.qi.Xi(Math.ceil(Math.max(i, s)) - .11111111111111, r))) } var h; n.restore(); const l = t || 34; return an(Math.ceil(i.S + i.C + i.V + i.A + 5 + l)) } Np(t) { null !== this.mp && Gi(this.mp, t) || (this.mp = t, this.xp = !0, this.Dp.resizeCanvasElement(t), this.Ep.resizeCanvasElement(t), this.xp = !1, this.kf.style.width = `${t.width}px`, this.kf.style.height = `${t.height}px`) } Wp() { return a(this.mp).width } ln(t) { this.qi !== t && (null !== this.qi && this.qi.Hl().u(this), this.qi = t, t.Hl().i(this.il.bind(this), this)) } Wt() { return this.qi } Is() { const t = this.yt.Wf(); this.yt.Cp().Qt().Vo(t, a(this.Wt())) } Fp(t) { if (null === this.mp) return; const i = { colorSpace: this.yt.Cp().N().layout.colorSpace }; if (1 !== t) { this.Hp(), this.Dp.applySuggestedBitmapSize(); const t = sn(this.Dp, i); null !== t && (t.useBitmapCoordinateSpace((t => { this.Up(t), this.$p(t) })), this.yt.jp(t, this.Rp), this.qp(t), this.yt.jp(t, this.Pp), this.Yp(t)) } this.Ep.applySuggestedBitmapSize(); const n = sn(this.Ep, i); null !== n && (n.useBitmapCoordinateSpace((({ context: t, bitmapSize: i }) => { t.clearRect(0, 0, i.width, i.height) })), this.Zp(n), this.yt.jp(n, this.Tp)) } Ef() { return this.Dp.bitmapSize } If(t, i, n) { const s = this.Ef(); s.width > 0 && s.height > 0 && t.drawImage(this.Dp.canvasElement, i, n) } kt() { this.qi?.Ea() } Of(t) { if (null === this.qi || this.qi.Zi() || !this.Sn.handleScale.axisPressedMouseMove.price) return; const i = this.yt.Cp().Qt(), n = this.yt.Wf(); this.wp = !0, i.ko(n, this.qi, t.localY) } Lf(t) { if (null === this.qi || !this.Sn.handleScale.axisPressedMouseMove.price) return; const i = this.yt.Cp().Qt(), n = this.yt.Wf(), s = this.qi; i.Po(n, s, t.localY) } Ip() { if (null === this.qi || !this.Sn.handleScale.axisPressedMouseMove.price) return; const t = this.yt.Cp().Qt(), i = this.yt.Wf(), n = this.qi; this.wp && (this.wp = !1, t.To(i, n)) } Nf(t) { if (null === this.qi || !this.Sn.handleScale.axisPressedMouseMove.price) return; const i = this.yt.Cp().Qt(), n = this.yt.Wf(); this.wp = !1, i.To(n, this.qi) } Vp(t) { this.Sn.handleScale.axisDoubleClickReset.price && this.Is() } Ap(t) { if (null === this.qi) return; !this.yt.Cp().Qt().N().handleScale.axisPressedMouseMove.price || this.qi.Oe() || this.qi.gl() || this.Kp(1) } zf(t) { this.Kp(0) } Lp() { const t = [], i = null === this.qi ? void 0 : this.qi; return (n => { for (let s = 0; s < n.length; ++s) { const e = n[s].Nn(this.yt.Wf(), i); for (let i = 0; i < e.length; i++)t.push(e[i]) } })(this.yt.Wf().Dt()), t } Up({ context: t, bitmapSize: i }) { const { width: n, height: s } = i, e = this.yt.Wf().Qt(), r = e.$(), h = e.xc(); r === h ? V(t, 0, 0, n, s, r) : z(t, 0, 0, n, s, r, h) } $p({ context: t, bitmapSize: i, horizontalPixelRatio: n }) { if (null === this.mp || null === this.qi || !this.qi.N().borderVisible) return; t.fillStyle = this.qi.N().borderColor; const s = Math.max(1, Math.floor(this.Bp().S * n)); let e; e = this.kp ? i.width - s : 0, t.fillRect(e, 0, s, i.height) } qp(t) { if (null === this.mp || null === this.qi) return; const i = this.qi.Ea(), n = this.qi.N(), s = this.Bp(), e = this.kp ? this.mp.width - s.C : 0; n.borderVisible && n.ticksVisible && t.useBitmapCoordinateSpace((({ context: t, horizontalPixelRatio: r, verticalPixelRatio: h }) => { t.fillStyle = n.borderColor; const a = Math.max(1, Math.floor(h)), l = Math.floor(.5 * h), o = Math.round(s.C * r); t.beginPath(); for (const n of i) t.rect(Math.floor(e * r), Math.round(n.ka * h) - l, o, a); t.fill() })), t.useMediaCoordinateSpace((({ context: t }) => { t.font = this.Op(), t.fillStyle = n.textColor ?? this._l.textColor, t.textAlign = this.kp ? "right" : "left", t.textBaseline = "middle"; const r = this.kp ? Math.round(e - s.V) : Math.round(e + s.C + s.V), h = i.map((i => this.gp.Di(t, i.$a))); for (let n = i.length; n--;) { const s = i[n]; t.fillText(s.$a, r, s.ka + h[n]) } })) } Hp() { if (null === this.mp || null === this.qi) return; let t = this.mp.height / 2; const i = [], n = this.qi.Dt().slice(), s = this.yt.Wf(), e = this.Bp(); this.qi === s.$s() && this.yt.Wf().Dt().forEach((t => { s.Us(t) && n.push(t) })); const r = this.qi.ba()[0], h = this.qi; n.forEach((n => { const e = n.Nn(s, h); e.forEach((t => { t.Fi(null), t.Hi() && i.push(t) })), r === n && e.length > 0 && (t = e[0].Vi()) })), i.forEach((t => t.Fi(t.Vi()))); this.qi.N().alignLabels && this.Xp(i, e, t) } Xp(t, i, n) { if (null === this.mp) return; const s = t.filter((t => t.Vi() <= n)), e = t.filter((t => t.Vi() > n)); s.sort(((t, i) => i.Vi() - t.Vi())), s.length && e.length && e.push(s[0]), e.sort(((t, i) => t.Vi() - i.Vi())); for (const n of t) { const t = Math.floor(n.$t(i) / 2), s = n.Vi(); s > -t && s < t && n.Fi(t), s > this.mp.height - t && s < this.mp.height + t && n.Fi(this.mp.height - t) } kn(s, 1, this.mp.height, i), kn(e, -1, this.mp.height, i) } Yp(t) { if (null === this.mp) return; const i = this.Lp(), n = this.Bp(), s = this.kp ? "right" : "left"; i.forEach((i => { if (i.Ui()) { i.Tt(a(this.qi)).st(t, n, this.gp, s) } })) } Zp(t) { if (null === this.mp || null === this.qi) return; const i = this.yt.Cp().Qt(), n = [], s = this.yt.Wf(), e = i.qu().Nn(s, this.qi); e.length && n.push(e); const r = this.Bp(), h = this.kp ? "right" : "left"; n.forEach((i => { i.forEach((i => { i.Tt(a(this.qi)).st(t, r, this.gp, h) })) })) } Kp(t) { this.kf.style.cursor = 1 === t ? "ns-resize" : "default" } il() { const t = this.zp(); this.bp < t && this.yt.Cp().Qt().Vh(), this.bp = t } Op() { return g(this._l.fontSize, this._l.fontFamily) } } function Tn(t, i) { return t.Jh?.(i) ?? [] } function Rn(t, i) { return t.Ln?.(i) ?? [] } function Dn(t, i) { return t._n?.(i) ?? [] } function En(t, i) { return t.Kh?.(i) ?? [] } class In { constructor(t, i) { this.mp = Xi({ width: 0, height: 0 }), this.Gp = null, this.Jp = null, this.Qp = null, this.tv = null, this.iv = !1, this.nv = new o, this.sv = new o, this.ev = 0, this.rv = !1, this.hv = null, this.av = !1, this.lv = null, this.ov = null, this.xp = !1, this.Sp = () => { this.xp || null === this._v || this.tn().ar() }, this.yp = () => { this.xp || null === this._v || this.tn().ar() }, this._p = t, this._v = i, this._v.zo().i(this.uv.bind(this), this, !0), this.cv = document.createElement("td"), this.cv.style.padding = "0", this.cv.style.position = "relative"; const n = document.createElement("div"); n.style.width = "100%", n.style.height = "100%", n.style.position = "relative", n.style.overflow = "hidden", this.dv = document.createElement("td"), this.dv.style.padding = "0", this.fv = document.createElement("td"), this.fv.style.padding = "0", this.cv.appendChild(n), this.Dp = Mn(n, Xi({ width: 16, height: 16 })), this.Dp.subscribeSuggestedBitmapSizeChanged(this.Sp); const s = this.Dp.canvasElement; s.style.position = "absolute", s.style.zIndex = "1", s.style.left = "0", s.style.top = "0", this.Ep = Mn(n, Xi({ width: 16, height: 16 })), this.Ep.subscribeSuggestedBitmapSizeChanged(this.yp); const e = this.Ep.canvasElement; e.style.position = "absolute", e.style.zIndex = "2", e.style.left = "0", e.style.top = "0", this.yf = document.createElement("tr"), this.yf.appendChild(this.dv), this.yf.appendChild(this.cv), this.yf.appendChild(this.fv), this.pv(), this.wf = new on(this.Ep.canvasElement, this, { Wd: () => null === this.hv && !this._p.N().handleScroll.vertTouchDrag, Fd: () => null === this.hv && !this._p.N().handleScroll.horzTouchDrag }) } m() { null !== this.Gp && this.Gp.m(), null !== this.Jp && this.Jp.m(), this.Qp = null, this.Ep.unsubscribeSuggestedBitmapSizeChanged(this.yp), bn(this.Ep.canvasElement), this.Ep.dispose(), this.Dp.unsubscribeSuggestedBitmapSizeChanged(this.Sp), bn(this.Dp.canvasElement), this.Dp.dispose(), null !== this._v && (this._v.zo().u(this), this._v.m()), this.wf.m() } Wf() { return a(this._v) } vv(t) { null !== this._v && this._v.zo().u(this), this._v = t, null !== this._v && this._v.zo().i(In.prototype.uv.bind(this), this, !0), this.pv(), this._p.Sf().indexOf(this) === this._p.Sf().length - 1 ? (this.Qp = this.Qp ?? new gn(this.cv, this._p), this.Qp.kt()) : (this.Qp?.cp(), this.Qp = null) } Cp() { return this._p } Rf() { return this.yf } pv() { if (null !== this._v && (this.mv(), 0 !== this.tn().jn().length)) { if (null !== this.Gp) { const t = this._v.Co(); this.Gp.ln(a(t)) } if (null !== this.Jp) { const t = this._v.yo(); this.Jp.ln(a(t)) } } } wv() { null !== this.Gp && this.Gp.kt(), null !== this.Jp && this.Jp.kt() } fo() { return null !== this._v ? this._v.fo() : 0 } po(t) { this._v && this._v.po(t) } Bd(t) { if (!this._v) return; this.gv(); const i = t.localX, n = t.localY; this.Mv(i, n, t) } tf(t) { this.gv(), this.bv(), this.Mv(t.localX, t.localY, t) } zd(t) { if (!this._v) return; this.gv(); const i = t.localX, n = t.localY; this.Mv(i, n, t) } Kd(t) { null !== this._v && (this.gv(), this.xv(t)) } Td(t) { null !== this._v && this.Sv(this.sv, t) } Cd(t) { this.Td(t) } $d(t) { this.gv(), this.Cv(t), this.Mv(t.localX, t.localY, t) } Zd(t) { null !== this._v && (this.gv(), this.rv = !1, this.yv(t)) } Yd(t) { null !== this._v && this.xv(t) } cf(t) { if (this.rv = !0, null === this.hv) { const i = { x: t.localX, y: t.localY }; this.kv(i, i, t) } } uf(t) { null !== this._v && (this.gv(), this._v.Qt().Uu(null), this.Pv()) } Tv() { return this.nv } Rv() { return this.sv } ef() { this.ev = 1, this.tn().es() } rf(t, i) { if (!this._p.N().handleScale.pinch) return; const n = 5 * (i - this.ev); this.ev = i, this.tn().tc(t._t, n) } Jd(t) { this.rv = !1, this.av = null !== this.hv, this.bv(); const i = this.tn().qu(); null !== this.hv && i.Et() && (this.lv = { x: i.ni(), y: i.si() }, this.hv = { x: t.localX, y: t.localY }) } Hd(t) { if (null === this._v) return; const i = t.localX, n = t.localY; if (null === this.hv) this.Cv(t); else { this.av = !1; const s = a(this.lv), e = s.x + (i - this.hv.x), r = s.y + (n - this.hv.y); this.Mv(e, r, t) } } qd(t) { 0 === this.Cp().N().trackingMode.exitMode && (this.av = !0), this.Dv(), this.yv(t) } Ys(t, i) { const n = this._v; return null === n ? null : wi(n, t, i) } Ev(t, i) { a("left" === i ? this.Gp : this.Jp).Np(Xi({ width: t, height: this.mp.height })) } Df() { return this.mp } Np(t) { Gi(this.mp, t) || (this.mp = t, this.xp = !0, this.Dp.resizeCanvasElement(t), this.Ep.resizeCanvasElement(t), this.xp = !1, this.cv.style.width = t.width + "px", this.cv.style.height = t.height + "px") } Iv() { const t = a(this._v); t.So(t.Co()), t.So(t.yo()); for (const i of t.ba()) if (t.Us(i)) { const n = i.Wt(); null !== n && t.So(n), i.On() } for (const i of t.Lo()) i.On() } Ef() { return this.Dp.bitmapSize } If(t, i, n) { const s = this.Ef(); s.width > 0 && s.height > 0 && t.drawImage(this.Dp.canvasElement, i, n) } Fp(t) { if (0 === t) return; if (null === this._v) return; t > 1 && this.Iv(), null !== this.Gp && this.Gp.Fp(t), null !== this.Jp && this.Jp.Fp(t); const i = { colorSpace: this._p.N().layout.colorSpace }; if (1 !== t) { this.Dp.applySuggestedBitmapSize(); const t = sn(this.Dp, i); null !== t && (t.useBitmapCoordinateSpace((t => { this.Up(t) })), this._v && (this.Vv(t, Tn), this.Av(t), this.Vv(t, Rn), this.Vv(t, Dn))) } this.Ep.applySuggestedBitmapSize(); const n = sn(this.Ep, i); null !== n && (n.useBitmapCoordinateSpace((({ context: t, bitmapSize: i }) => { t.clearRect(0, 0, i.width, i.height) })), this.Bv(n), this.Vv(n, En), this.Vv(n, Dn)) } zv() { return this.Gp } Ov() { return this.Jp } jp(t, i) { this.Vv(t, i) } uv() { null !== this._v && this._v.zo().u(this), this._v = null } xv(t) { this.Sv(this.nv, t) } Sv(t, i) { const n = i.localX, s = i.localY; t.v() && t.p(this.tn().At().Z_(n), { x: n, y: s }, i) } Up({ context: t, bitmapSize: i }) { const { width: n, height: s } = i, e = this.tn(), r = e.$(), h = e.xc(); r === h ? V(t, 0, 0, n, s, h) : z(t, 0, 0, n, s, r, h) } Av(t) { const i = a(this._v), n = i.Oo().lr().Tt(i); null !== n && n.st(t, !1) } Bv(t) { this.Lv(t, Rn, Sn, this.tn().qu()) } Vv(t, i) { const n = a(this._v), s = n.Dt(), e = n.Lo(); for (const n of e) this.Lv(t, i, xn, n); for (const n of s) this.Lv(t, i, xn, n); for (const n of e) this.Lv(t, i, Sn, n); for (const n of s) this.Lv(t, i, Sn, n) } Lv(t, i, n, s) { const e = a(this._v), r = e.Qt().Hu(), h = null !== r && r.Wo === s, l = null !== r && h && void 0 !== r.Fo ? r.Fo.Ks : void 0; Cn(i, (i => n(i, t, h, l)), s, e) } mv() { if (null === this._v) return; const t = this._p, i = this._v.Co().N().visible, n = this._v.yo().N().visible; i || null === this.Gp || (this.dv.removeChild(this.Gp.Rf()), this.Gp.m(), this.Gp = null), n || null === this.Jp || (this.fv.removeChild(this.Jp.Rf()), this.Jp.m(), this.Jp = null); const s = t.Qt().cc(); i && null === this.Gp && (this.Gp = new Pn(this, t.N(), s, "left"), this.dv.appendChild(this.Gp.Rf())), n && null === this.Jp && (this.Jp = new Pn(this, t.N(), s, "right"), this.fv.appendChild(this.Jp.Rf())) } Nv(t) { return t.df && this.rv || null !== this.hv } Wv(t) { return Math.max(0, Math.min(t, this.mp.width - 1)) } Fv(t) { return Math.max(0, Math.min(t, this.mp.height - 1)) } Mv(t, i, n) { this.tn().lc(this.Wv(t), this.Fv(i), n, a(this._v)) } Pv() { this.tn()._c() } Dv() { this.av && (this.hv = null, this.Pv()) } kv(t, i, n) { this.hv = t, this.av = !1, this.Mv(i.x, i.y, n); const s = this.tn().qu(); this.lv = { x: s.ni(), y: s.si() } } tn() { return this._p.Qt() } yv(t) { if (!this.iv) return; const i = this.tn(), n = this.Wf(); if (i.Eo(n, n.yn()), this.tv = null, this.iv = !1, i.rc(), null !== this.ov) { const t = performance.now(), n = i.At(); this.ov.le(n.iu(), t), this.ov.uu(t) || i.ls(this.ov) } } gv() { this.hv = null } bv() { if (!this._v) return; if (this.tn().es(), document.activeElement !== document.body && document.activeElement !== document.documentElement) a(document.activeElement).blur(); else { const t = document.getSelection(); null !== t && t.removeAllRanges() } !this._v.yn().Zi() && this.tn().At().Zi() } Cv(t) { if (null === this._v) return; const i = this.tn(), n = i.At(); if (n.Zi()) return; const s = this._p.N(), e = s.handleScroll, r = s.kineticScroll; if ((!e.pressedMouseMove || t.df) && (!e.horzTouchDrag && !e.vertTouchDrag || !t.df)) return; const h = this._v.yn(), a = performance.now(); if (null !== this.tv || this.Nv(t) || (this.tv = { x: t.clientX, y: t.clientY, Oc: a, Hv: t.localX, Uv: t.localY }), null !== this.tv && !this.iv && (this.tv.x !== t.clientX || this.tv.y !== t.clientY)) { if (t.df && r.touch || !t.df && r.mouse) { const t = n.Q_(); this.ov = new wn(.2 / t, 7 / t, .997, 15 / t), this.ov.ep(n.iu(), this.tv.Oc) } else this.ov = null; h.Zi() || i.Ro(this._v, h, t.localY), i.sc(t.localX), this.iv = !0 } this.iv && (h.Zi() || i.Do(this._v, h, t.localY), i.ec(t.localX), null !== this.ov && this.ov.ep(n.iu(), a)) } } class Vn { constructor(t, i, n, s, e) { this.St = !0, this.mp = Xi({ width: 0, height: 0 }), this.Sp = () => this.Fp(3), this.kp = "left" === t, this.Au = n.cc, this.Sn = i, this.$v = s, this.jv = e, this.kf = document.createElement("div"), this.kf.style.width = "25px", this.kf.style.height = "100%", this.kf.style.overflow = "hidden", this.Dp = Mn(this.kf, Xi({ width: 16, height: 16 })), this.Dp.subscribeSuggestedBitmapSizeChanged(this.Sp) } m() { this.Dp.unsubscribeSuggestedBitmapSizeChanged(this.Sp), bn(this.Dp.canvasElement), this.Dp.dispose() } Rf() { return this.kf } Df() { return this.mp } Np(t) { Gi(this.mp, t) || (this.mp = t, this.Dp.resizeCanvasElement(t), this.kf.style.width = `${t.width}px`, this.kf.style.height = `${t.height}px`, this.St = !0) } Fp(t) { if (t < 3 && !this.St) return; if (0 === this.mp.width || 0 === this.mp.height) return; this.St = !1, this.Dp.applySuggestedBitmapSize(); const i = sn(this.Dp, { colorSpace: this.Sn.layout.colorSpace }); null !== i && i.useBitmapCoordinateSpace((t => { this.Up(t), this.$p(t) })) } Ef() { return this.Dp.bitmapSize } If(t, i, n) { const s = this.Ef(); s.width > 0 && s.height > 0 && t.drawImage(this.Dp.canvasElement, i, n) } $p({ context: t, bitmapSize: i, horizontalPixelRatio: n, verticalPixelRatio: s }) { if (!this.$v()) return; t.fillStyle = this.Sn.timeScale.borderColor; const e = Math.floor(this.Au.N().S * n), r = Math.floor(this.Au.N().S * s), h = this.kp ? i.width - e : 0; t.fillRect(h, 0, e, r) } Up({ context: t, bitmapSize: i }) { V(t, 0, 0, i.width, i.height, this.jv()) } } function An(t) { return i => i.ia?.(t) ?? [] } const Bn = An("normal"), zn = An("top"), On = An("bottom"); class Ln { constructor(t, i) { this.qv = null, this.Yv = null, this.M = null, this.Zv = !1, this.mp = Xi({ width: 0, height: 0 }), this.Kv = new o, this.gp = new tt(5), this.xp = !1, this.Sp = () => { this.xp || this._p.Qt().ar() }, this.yp = () => { this.xp || this._p.Qt().ar() }, this._p = t, this.qo = i, this.Sn = t.N().layout, this.hp = document.createElement("tr"), this.Xv = document.createElement("td"), this.Xv.style.padding = "0", this.Gv = document.createElement("td"), this.Gv.style.padding = "0", this.kf = document.createElement("td"), this.kf.style.height = "25px", this.kf.style.padding = "0", this.Jv = document.createElement("div"), this.Jv.style.width = "100%", this.Jv.style.height = "100%", this.Jv.style.position = "relative", this.Jv.style.overflow = "hidden", this.kf.appendChild(this.Jv), this.Dp = Mn(this.Jv, Xi({ width: 16, height: 16 })), this.Dp.subscribeSuggestedBitmapSizeChanged(this.Sp); const n = this.Dp.canvasElement; n.style.position = "absolute", n.style.zIndex = "1", n.style.left = "0", n.style.top = "0", this.Ep = Mn(this.Jv, Xi({ width: 16, height: 16 })), this.Ep.subscribeSuggestedBitmapSizeChanged(this.yp); const s = this.Ep.canvasElement; s.style.position = "absolute", s.style.zIndex = "2", s.style.left = "0", s.style.top = "0", this.hp.appendChild(this.Xv), this.hp.appendChild(this.kf), this.hp.appendChild(this.Gv), this.Qv(), this._p.Qt().do().i(this.Qv.bind(this), this), this.wf = new on(this.Ep.canvasElement, this, { Wd: () => !0, Fd: () => !this._p.N().handleScroll.horzTouchDrag }) } m() { this.wf.m(), null !== this.qv && this.qv.m(), null !== this.Yv && this.Yv.m(), this.Ep.unsubscribeSuggestedBitmapSizeChanged(this.yp), bn(this.Ep.canvasElement), this.Ep.dispose(), this.Dp.unsubscribeSuggestedBitmapSizeChanged(this.Sp), bn(this.Dp.canvasElement), this.Dp.dispose() } Rf() { return this.hp } tm() { return this.qv } im() { return this.Yv } tf(t) { if (this.Zv) return; this.Zv = !0; const i = this._p.Qt(); !i.At().Zi() && this._p.N().handleScale.axisPressedMouseMove.time && i.Qu(t.localX) } Jd(t) { this.tf(t) } if() { const t = this._p.Qt(); !t.At().Zi() && this.Zv && (this.Zv = !1, this._p.N().handleScale.axisPressedMouseMove.time && t.ac()) } $d(t) { const i = this._p.Qt(); !i.At().Zi() && this._p.N().handleScale.axisPressedMouseMove.time && i.hc(t.localX) } Hd(t) { this.$d(t) } Zd() { this.Zv = !1; const t = this._p.Qt(); t.At().Zi() && !this._p.N().handleScale.axisPressedMouseMove.time || t.ac() } qd() { this.Zd() } Td() { this._p.N().handleScale.axisDoubleClickReset.time && this._p.Qt().us() } Cd() { this.Td() } Bd() { this._p.Qt().N().handleScale.axisPressedMouseMove.time && this.Kp(1) } uf() { this.Kp(0) } Df() { return this.mp } nm() { return this.Kv } sm(t, i, n) { Gi(this.mp, t) || (this.mp = t, this.xp = !0, this.Dp.resizeCanvasElement(t), this.Ep.resizeCanvasElement(t), this.xp = !1, this.kf.style.width = `${t.width}px`, this.kf.style.height = `${t.height}px`, this.Kv.p(t)), null !== this.qv && this.qv.Np(Xi({ width: i, height: t.height })), null !== this.Yv && this.Yv.Np(Xi({ width: n, height: t.height })) } rm() { const t = this.hm(); return Math.ceil(t.S + t.C + t.k + t.B + t.I + t.am) } kt() { this._p.Qt().At().Ea() } Ef() { return this.Dp.bitmapSize } If(t, i, n) { const s = this.Ef(); s.width > 0 && s.height > 0 && t.drawImage(this.Dp.canvasElement, i, n) } Fp(t) { if (0 === t) return; const i = { colorSpace: this.Sn.colorSpace }; if (1 !== t) { this.Dp.applySuggestedBitmapSize(); const n = sn(this.Dp, i); null !== n && (n.useBitmapCoordinateSpace((t => { this.Up(t), this.$p(t), this.lm(n, On) })), this.qp(n), this.lm(n, Bn)), null !== this.qv && this.qv.Fp(t), null !== this.Yv && this.Yv.Fp(t) } this.Ep.applySuggestedBitmapSize(); const n = sn(this.Ep, i); null !== n && (n.useBitmapCoordinateSpace((({ context: t, bitmapSize: i }) => { t.clearRect(0, 0, i.width, i.height) })), this.om([...this._p.Qt().jn(), this._p.Qt().qu()], n), this.lm(n, zn)) } lm(t, i) { const n = this._p.Qt().jn(); for (const s of n) Cn(i, (i => xn(i, t, !1, void 0)), s, void 0); for (const s of n) Cn(i, (i => Sn(i, t, !1, void 0)), s, void 0) } Up({ context: t, bitmapSize: i }) { V(t, 0, 0, i.width, i.height, this._p.Qt().xc()) } $p({ context: t, bitmapSize: i, verticalPixelRatio: n }) { if (this._p.N().timeScale.borderVisible) { t.fillStyle = this._m(); const s = Math.max(1, Math.floor(this.hm().S * n)); t.fillRect(0, 0, i.width, s) } } qp(t) { const i = this._p.Qt().At(), n = i.Ea(); if (!n || 0 === n.length) return; const s = this.qo.maxTickMarkWeight(n), e = this.hm(), r = i.N(); r.borderVisible && r.ticksVisible && t.useBitmapCoordinateSpace((({ context: t, horizontalPixelRatio: i, verticalPixelRatio: s }) => { t.strokeStyle = this._m(), t.fillStyle = this._m(); const r = Math.max(1, Math.floor(i)), h = Math.floor(.5 * i); t.beginPath(); const a = Math.round(e.C * s); for (let s = n.length; s--;) { const e = Math.round(n[s].coord * i); t.rect(e - h, 0, r, a) } t.fill() })), t.useMediaCoordinateSpace((({ context: t }) => { const i = e.S + e.C + e.B + e.k / 2; t.textAlign = "center", t.textBaseline = "middle", t.fillStyle = this.H(), t.font = this.Op(); for (const e of n) if (e.weight < s) { const n = e.needAlignCoordinate ? this.um(t, e.coord, e.label) : e.coord; t.fillText(e.label, n, i) } this._p.N().timeScale.allowBoldLabels && (t.font = this.dm()); for (const e of n) if (e.weight >= s) { const n = e.needAlignCoordinate ? this.um(t, e.coord, e.label) : e.coord; t.fillText(e.label, n, i) } })) } um(t, i, n) { const s = this.gp.Ei(t, n), e = s / 2, r = Math.floor(i - e) + .5; return r < 0 ? i += Math.abs(0 - r) : r + s > this.mp.width && (i -= Math.abs(this.mp.width - (r + s))), i } om(t, i) { const n = this.hm(); for (const s of t) for (const t of s.un()) t.Tt().st(i, n) } _m() { return this._p.N().timeScale.borderColor } H() { return this.Sn.textColor } W() { return this.Sn.fontSize } Op() { return g(this.W(), this.Sn.fontFamily) } dm() { return g(this.W(), this.Sn.fontFamily, "bold") } hm() { null === this.M && (this.M = { S: 1, O: NaN, B: NaN, I: NaN, Ji: NaN, C: 5, k: NaN, P: "", Gi: new tt, am: 0 }); const t = this.M, i = this.Op(); if (t.P !== i) { const n = this.W(); t.k = n, t.P = i, t.B = 3 * n / 12, t.I = 3 * n / 12, t.Ji = 9 * n / 12, t.O = 0, t.am = 4 * n / 12, t.Gi.Is() } return this.M } Kp(t) { this.kf.style.cursor = 1 === t ? "ew-resize" : "default" } Qv() { const t = this._p.Qt(), i = t.N(); i.leftPriceScale.visible || null === this.qv || (this.Xv.removeChild(this.qv.Rf()), this.qv.m(), this.qv = null), i.rightPriceScale.visible || null === this.Yv || (this.Gv.removeChild(this.Yv.Rf()), this.Yv.m(), this.Yv = null); const n = { cc: this._p.Qt().cc() }, s = () => i.leftPriceScale.borderVisible && t.At().N().borderVisible, e = () => t.xc(); i.leftPriceScale.visible && null === this.qv && (this.qv = new Vn("left", i, n, s, e), this.Xv.appendChild(this.qv.Rf())), i.rightPriceScale.visible && null === this.Yv && (this.Yv = new Vn("right", i, n, s, e), this.Gv.appendChild(this.Yv.Rf())) } } const Nn = !!en && !!navigator.userAgentData && navigator.userAgentData.brands.some((t => t.brand.includes("Chromium"))) && !!en && (navigator?.userAgentData?.platform ? "Windows" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf("win") >= 0); class Wn { constructor(t, i, n) { var s; this.fm = [], this.pm = [], this.vm = 0, this.Ya = 0, this.so = 0, this.wm = 0, this.gm = 0, this.Mm = null, this.bm = !1, this.nv = new o, this.sv = new o, this.Eu = new o, this.xm = null, this.Sm = null, this.op = t, this.Sn = i, this.qo = n, this.hp = document.createElement("div"), this.hp.classList.add("tv-lightweight-charts"), this.hp.style.overflow = "hidden", this.hp.style.direction = "ltr", this.hp.style.width = "100%", this.hp.style.height = "100%", (s = this.hp).style.userSelect = "none", s.style.webkitUserSelect = "none", s.style.msUserSelect = "none", s.style.MozUserSelect = "none", s.style.webkitTapHighlightColor = "transparent", this.Cm = document.createElement("table"), this.Cm.setAttribute("cellspacing", "0"), this.hp.appendChild(this.Cm), this.ym = this.km.bind(this), Fn(this.Sn) && this.Pm(!0), this.tn = new Ei(this.Vu.bind(this), this.Sn, n), this.Qt().Yu().i(this.Tm.bind(this), this), this.Rm = new Ln(this, this.qo), this.Cm.appendChild(this.Rm.Rf()); const e = i.autoSize && this.Dm(); let r = this.Sn.width, h = this.Sn.height; if (e || 0 === r || 0 === h) { const i = t.getBoundingClientRect(); r = r || i.width, h = h || i.height } this.Em(r, h), this.Im(), t.appendChild(this.hp), this.Vm(), this.tn.At().pu().i(this.tn.Vh.bind(this.tn), this), this.tn.do().i(this.tn.Vh.bind(this.tn), this) } Qt() { return this.tn } N() { return this.Sn } Sf() { return this.fm } Am() { return this.Rm } m() { this.Pm(!1), 0 !== this.vm && window.cancelAnimationFrame(this.vm), this.tn.Yu().u(this), this.tn.At().pu().u(this), this.tn.do().u(this), this.tn.m(); for (const t of this.fm) this.Cm.removeChild(t.Rf()), t.Tv().u(this), t.Rv().u(this), t.m(); this.fm = []; for (const t of this.pm) this.Bm(t); this.pm = [], a(this.Rm).m(), null !== this.hp.parentElement && this.hp.parentElement.removeChild(this.hp), this.Eu.m(), this.nv.m(), this.sv.m(), this.zm() } Em(t, i, n = !1) { if (this.Ya === i && this.so === t) return; const s = function (t) { const i = Math.floor(t.width), n = Math.floor(t.height); return Xi({ width: i - i % 2, height: n - n % 2 }) }(Xi({ width: t, height: i })); this.Ya = s.height, this.so = s.width; const e = this.Ya + "px", r = this.so + "px"; a(this.hp).style.height = e, a(this.hp).style.width = r, this.Cm.style.height = e, this.Cm.style.width = r, n ? this.Om(Y.gs(), performance.now()) : this.tn.Vh() } Fp(t) { void 0 === t && (t = Y.gs()); for (let i = 0; i < this.fm.length; i++)this.fm[i].Fp(t.ns(i).Jn); this.Sn.timeScale.visible && this.Rm.Fp(t.ts()) } hr(t) { const i = Fn(this.Sn); this.tn.hr(t); const n = Fn(this.Sn); n !== i && this.Pm(n), t.layout?.panes && this.Lm(), this.Vm(), this.Nm(t) } Tv() { return this.nv } Rv() { return this.sv } Yu() { return this.Eu } Wm() { null !== this.Mm && (this.Om(this.Mm, performance.now()), this.Mm = null); const t = this.Fm(null), i = document.createElement("canvas"); i.width = t.width, i.height = t.height; const n = a(i.getContext("2d")); return this.Fm(n), i } Hm(t) { if ("left" === t && !this.Um()) return 0; if ("right" === t && !this.$m()) return 0; if (0 === this.fm.length) return 0; return a("left" === t ? this.fm[0].zv() : this.fm[0].Ov()).Wp() } jm() { return this.Sn.autoSize && null !== this.xm } Af() { return this.hp } qm(t) { this.Sm = t, this.Sm ? this.Af().style.setProperty("cursor", t) : this.Af().style.removeProperty("cursor") } Ym() { return this.Sm } Zm(t) { return h(this.fm[t]).Df() } Lm() { this.pm.forEach((t => { t.kt() })) } Nm(t) { (void 0 !== t.autoSize || !this.xm || void 0 === t.width && void 0 === t.height) && (t.autoSize && !this.xm && this.Dm(), !1 === t.autoSize && null !== this.xm && this.zm(), t.autoSize || void 0 === t.width && void 0 === t.height || this.Em(t.width || this.so, t.height || this.Ya)) } Fm(t) { let i = 0, n = 0; const s = this.fm[0], e = (i, n) => { let s = 0; for (let e = 0; e < this.fm.length; e++) { const r = this.fm[e], h = a("left" === i ? r.zv() : r.Ov()), l = h.Ef(); if (null !== t && h.If(t, n, s), s += l.height, e < this.fm.length - 1) { const i = this.pm[e], r = i.Ef(); null !== t && i.If(t, n, s), s += r.height } } }; if (this.Um()) { e("left", 0); i += a(s.zv()).Ef().width } for (let s = 0; s < this.fm.length; s++) { const e = this.fm[s], r = e.Ef(); if (null !== t && e.If(t, i, n), n += r.height, s < this.fm.length - 1) { const e = this.pm[s], r = e.Ef(); null !== t && e.If(t, i, n), n += r.height } } if (i += s.Ef().width, this.$m()) { e("right", i); i += a(s.Ov()).Ef().width } const r = (i, n, s) => { a("left" === i ? this.Rm.tm() : this.Rm.im()).If(a(t), n, s) }; if (this.Sn.timeScale.visible) { const i = this.Rm.Ef(); if (null !== t) { let e = 0; this.Um() && (r("left", e, n), e = a(s.zv()).Ef().width), this.Rm.If(t, e, n), e += i.width, this.$m() && r("right", e, n) } n += i.height } return Xi({ width: i, height: n }) } Km() { let t = 0, i = 0, n = 0; for (const s of this.fm) this.Um() && (i = Math.max(i, a(s.zv()).zp(), this.Sn.leftPriceScale.minimumWidth)), this.$m() && (n = Math.max(n, a(s.Ov()).zp(), this.Sn.rightPriceScale.minimumWidth)), t += s.fo(); i = an(i), n = an(n); const s = this.so, e = this.Ya, r = Math.max(s - i - n, 0), h = 1 * this.pm.length, l = this.Sn.timeScale.visible; let o = l ? Math.max(this.Rm.rm(), this.Sn.timeScale.minimumHeight) : 0; var _; o = (_ = o) + _ % 2; const u = h + o, c = e < u ? 0 : e - u, d = c / t; let f = 0; const p = window.devicePixelRatio || 1; for (let t = 0; t < this.fm.length; ++t) { const s = this.fm[t]; s.vv(this.tn.Hn()[t]); let e = 0, h = 0; h = t === this.fm.length - 1 ? Math.ceil((c - f) * p) / p : Math.round(s.fo() * d * p) / p, e = Math.max(h, 2), f += e, s.Np(Xi({ width: r, height: e })), this.Um() && s.Ev(i, "left"), this.$m() && s.Ev(n, "right"), s.Wf() && this.tn.Zu(s.Wf(), e) } this.Rm.sm(Xi({ width: l ? r : 0, height: o }), l ? i : 0, l ? n : 0), this.tn.vo(r), this.wm !== i && (this.wm = i), this.gm !== n && (this.gm = n) } Pm(t) { t ? this.hp.addEventListener("wheel", this.ym, { passive: !1 }) : this.hp.removeEventListener("wheel", this.ym) } Xm(t) { switch (t.deltaMode) { case t.DOM_DELTA_PAGE: return 120; case t.DOM_DELTA_LINE: return 32 }return Nn ? 1 / window.devicePixelRatio : 1 } km(t) { if (!(0 !== t.deltaX && this.Sn.handleScroll.mouseWheel || 0 !== t.deltaY && this.Sn.handleScale.mouseWheel)) return; const i = this.Xm(t), n = i * t.deltaX / 100, s = -i * t.deltaY / 100; if (t.cancelable && t.preventDefault(), 0 !== s && this.Sn.handleScale.mouseWheel) { const i = Math.sign(s) * Math.min(1, Math.abs(s)), n = t.clientX - this.hp.getBoundingClientRect().left; this.Qt().tc(n, i) } 0 !== n && this.Sn.handleScroll.mouseWheel && this.Qt().nc(-80 * n) } Om(t, i) { const n = t.ts(); 3 === n && this.Gm(), 3 !== n && 2 !== n || (this.Jm(t), this.Qm(t, i), this.Rm.kt(), this.fm.forEach((t => { t.wv() })), 3 === this.Mm?.ts() && (this.Mm.ps(t), this.Gm(), this.Jm(this.Mm), this.Qm(this.Mm, i), t = this.Mm, this.Mm = null)), this.Fp(t) } Qm(t, i) { for (const n of t.fs()) this.vs(n, i) } Jm(t) { const i = this.tn.Hn(); for (let n = 0; n < i.length; n++)t.ns(n).Qn && i[n].Ao() } vs(t, i) { const n = this.tn.At(); switch (t.rs) { case 0: n.mu(); break; case 1: n.wu(t.Ft); break; case 2: n.cs(t.Ft); break; case 3: n.ds(t.Ft); break; case 4: n.eu(); break; case 5: t.Ft.uu(i) || n.ds(t.Ft.cu(i)) } } Vu(t) { null !== this.Mm ? this.Mm.ps(t) : this.Mm = t, this.bm || (this.bm = !0, this.vm = window.requestAnimationFrame((t => { if (this.bm = !1, this.vm = 0, null !== this.Mm) { const i = this.Mm; this.Mm = null, this.Om(i, t); for (const n of i.fs()) if (5 === n.rs && !n.Ft.uu(t)) { this.Qt().ls(n.Ft); break } } }))) } Gm() { this.Im() } Bm(t) { this.Cm.removeChild(t.Rf()), t.m() } Im() { const t = this.tn.Hn(), i = t.length, n = this.fm.length; for (let t = i; t < n; t++) { const t = h(this.fm.pop()); this.Cm.removeChild(t.Rf()), t.Tv().u(this), t.Rv().u(this), t.m(); const i = this.pm.pop(); void 0 !== i && this.Bm(i) } for (let s = n; s < i; s++) { const i = new In(this, t[s]); if (i.Tv().i(this.tw.bind(this, i), this), i.Rv().i(this.iw.bind(this, i), this), this.fm.push(i), s > 0) { const t = new pn(this, s - 1, s); this.pm.push(t), this.Cm.insertBefore(t.Rf(), this.Rm.Rf()) } this.Cm.insertBefore(i.Rf(), this.Rm.Rf()) } for (let n = 0; n < i; n++) { const i = t[n], s = this.fm[n]; s.Wf() !== i ? s.vv(i) : s.pv() } this.Vm(), this.Km() } nw(t, i, n, s) { const e = new Map; if (null !== t) { this.tn.jn().forEach((i => { const n = i.Yn().Wr(t); null !== n && e.set(i, n) })) } let r; if (null !== t) { const i = this.tn.At().nn(t)?.originalTime; void 0 !== i && (r = i) } const h = this.Qt().Hu(), a = null !== h && h.Wo instanceof Ht ? h.Wo : void 0, l = null !== h && void 0 !== h.Fo ? h.Fo.Zs : void 0, o = this.sw(s); return { ew: r, Re: t ?? void 0, rw: i ?? void 0, hw: -1 !== o ? o : void 0, aw: a, lw: e, ow: l, _w: n ?? void 0 } } sw(t) { let i = -1; if (t) i = this.fm.indexOf(t); else { const t = this.Qt().qu().Fn(); null !== t && (i = this.Qt().Hn().indexOf(t)) } return i } tw(t, i, n, s) { this.nv.p((() => this.nw(i, n, s, t))) } iw(t, i, n, s) { this.sv.p((() => this.nw(i, n, s, t))) } Tm(t, i, n) { this.qm(this.Qt().Hu()?.Uo ?? null), this.Eu.p((() => this.nw(t, i, n))) } Vm() { const t = this.Sn.timeScale.visible ? "" : "none"; this.Rm.Rf().style.display = t } Um() { return this.fm[0].Wf().Co().N().visible } $m() { return this.fm[0].Wf().yo().N().visible } Dm() { return "ResizeObserver" in window && (this.xm = new ResizeObserver((t => { const i = t[t.length - 1]; i && this.Em(i.contentRect.width, i.contentRect.height) })), this.xm.observe(this.op, { box: "border-box" }), !0) } zm() { null !== this.xm && this.xm.disconnect(), this.xm = null } } function Fn(t) { return Boolean(t.handleScroll.mouseWheel || t.handleScale.mouseWheel) } function Hn(t) { return void 0 === t.open && void 0 === t.value } function Un(t) { return function (t) { return void 0 !== t.open }(t) || function (t) { return void 0 !== t.value }(t) } function $n(t, i, n, s) { const e = n.value, r = { Re: i, wt: t, Ft: [e, e, e, e], ew: s }; return void 0 !== n.color && (r.R = n.color), r } function jn(t, i, n, s) { const e = n.value, r = { Re: i, wt: t, Ft: [e, e, e, e], ew: s }; return void 0 !== n.lineColor && (r.vt = n.lineColor), void 0 !== n.topColor && (r.mr = n.topColor), void 0 !== n.bottomColor && (r.wr = n.bottomColor), r } function qn(t, i, n, s) { const e = n.value, r = { Re: i, wt: t, Ft: [e, e, e, e], ew: s }; return void 0 !== n.topLineColor && (r.gr = n.topLineColor), void 0 !== n.bottomLineColor && (r.Mr = n.bottomLineColor), void 0 !== n.topFillColor1 && (r.br = n.topFillColor1), void 0 !== n.topFillColor2 && (r.Sr = n.topFillColor2), void 0 !== n.bottomFillColor1 && (r.Cr = n.bottomFillColor1), void 0 !== n.bottomFillColor2 && (r.yr = n.bottomFillColor2), r } function Yn(t, i, n, s) { const e = { Re: i, wt: t, Ft: [n.open, n.high, n.low, n.close], ew: s }; return void 0 !== n.color && (e.R = n.color), e } function Zn(t, i, n, s) { const e = { Re: i, wt: t, Ft: [n.open, n.high, n.low, n.close], ew: s }; return void 0 !== n.color && (e.R = n.color), void 0 !== n.borderColor && (e.Ht = n.borderColor), void 0 !== n.wickColor && (e.vr = n.wickColor), e } function Kn(t, i, n, s, e) { const r = h(e)(n), a = Math.max(...r), l = Math.min(...r), o = r[r.length - 1], _ = [o, a, l, o], { time: u, color: c, ...d } = n; return { Re: i, wt: t, Ft: _, ew: s, ne: d, R: c } } function Xn(t) { return void 0 !== t.Ft } function Gn(t, i) { return void 0 !== i.customValues && (t.uw = i.customValues), t } function Jn(t) { return (i, n, s, e, r, h) => function (t, i) { return i ? i(t) : Hn(t) }(s, h) ? Gn({ wt: i, Re: n, ew: e }, s) : Gn(t(i, n, s, e, r), s) } function Qn(t) { return { Candlestick: Jn(Zn), Bar: Jn(Yn), Area: Jn(jn), Baseline: Jn(qn), Histogram: Jn($n), Line: Jn($n), Custom: Jn(Kn) }[t] } function ts(t) { return { Re: 0, cw: new Map, Hh: t } } function is(t, i) { if (void 0 !== t && 0 !== t.length) return { dw: i.key(t[0].wt), fw: i.key(t[t.length - 1].wt) } } function ns(t) { let i; return t.forEach((t => { void 0 === i && (i = t.ew) })), h(i) } class ss { constructor(t) { this.pw = new Map, this.mw = new Map, this.ww = new Map, this.gw = [], this.qo = t } m() { this.pw.clear(), this.mw.clear(), this.ww.clear(), this.gw = [] } Mw(t, i) { let n = 0 !== this.pw.size, s = !1; const e = this.mw.get(t); if (void 0 !== e) if (1 === this.mw.size) n = !1, s = !0, this.pw.clear(); else for (const i of this.gw) i.pointData.cw.delete(t) && (s = !0); let r = []; if (0 !== i.length) { const n = i.map((t => t.time)), e = this.qo.createConverterToInternalObj(i), h = Qn(t.Rr()), a = t.da(), l = t.pa(); r = i.map(((i, r) => { const o = e(i.time), _ = this.qo.key(o); let u = this.pw.get(_); void 0 === u && (u = ts(o), this.pw.set(_, u), s = !0); const c = h(o, u.Re, i, n[r], a, l); return u.cw.set(t, c), c })) } n && this.bw(), this.xw(t, r); let h = -1; if (s) { const t = []; this.pw.forEach((i => { t.push({ timeWeight: 0, time: i.Hh, pointData: i, originalTime: ns(i.cw) }) })), t.sort(((t, i) => this.qo.key(t.time) - this.qo.key(i.time))), h = this.Sw(t) } return this.Cw(t, h, function (t, i, n) { const s = is(t, n), e = is(i, n); if (void 0 !== s && void 0 !== e) return { yw: !1, zh: s.fw >= e.fw && s.dw >= e.dw } }(this.mw.get(t), e, this.qo)) } vc(t) { return this.Mw(t, []) } kw(t, i, n) { const s = i; !function (t) { void 0 === t.ew && (t.ew = t.time) }(s), this.qo.preprocessData(i); const e = this.qo.createConverterToInternalObj([i])(i.time), r = this.ww.get(t); if (!n && void 0 !== r && this.qo.key(e) < this.qo.key(r)) throw new Error(`Cannot update oldest data, last time=${r}, new time=${e}`); let h = this.pw.get(this.qo.key(e)); if (n && void 0 === h) throw new Error("Cannot update non-existing data point when historicalUpdate is true"); const a = void 0 === h; void 0 === h && (h = ts(e), this.pw.set(this.qo.key(e), h)); const l = Qn(t.Rr()), o = t.da(), _ = t.pa(), u = l(e, h.Re, i, s.ew, o, _); h.cw.set(t, u), n ? this.Pw(t, u, h.Re) : this.Tw(t, u); const c = { zh: Xn(u), yw: n }; if (!a) return this.Cw(t, -1, c); const d = { timeWeight: 0, time: h.Hh, pointData: h, originalTime: ns(h.cw) }, f = bt(this.gw, this.qo.key(d.time), ((t, i) => this.qo.key(t.time) < i)); this.gw.splice(f, 0, d); for (let t = f; t < this.gw.length; ++t)es(this.gw[t].pointData, t); return this.qo.fillWeightsForPoints(this.gw, f), this.Cw(t, f, c) } Tw(t, i) { let n = this.mw.get(t); void 0 === n && (n = [], this.mw.set(t, n)); const s = 0 !== n.length ? n[n.length - 1] : null; null === s || this.qo.key(i.wt) > this.qo.key(s.wt) ? Xn(i) && n.push(i) : Xn(i) ? n[n.length - 1] = i : n.splice(-1, 1), this.ww.set(t, i.wt) } Pw(t, i, n) { const s = this.mw.get(t); if (void 0 === s) return; const e = bt(s, n, ((t, i) => t.Re < i)); Xn(i) ? s[e] = i : s.splice(e, 1) } xw(t, i) { 0 !== i.length ? (this.mw.set(t, i.filter(Xn)), this.ww.set(t, i[i.length - 1].wt)) : (this.mw.delete(t), this.ww.delete(t)) } bw() { for (const t of this.gw) 0 === t.pointData.cw.size && this.pw.delete(this.qo.key(t.time)) } Sw(t) { let i = -1; for (let n = 0; n < this.gw.length && n < t.length; ++n) { const s = this.gw[n], e = t[n]; if (this.qo.key(s.time) !== this.qo.key(e.time)) { i = n; break } e.timeWeight = s.timeWeight, es(e.pointData, n) } if (-1 === i && this.gw.length !== t.length && (i = Math.min(this.gw.length, t.length)), -1 === i) return -1; for (let n = i; n < t.length; ++n)es(t[n].pointData, n); return this.qo.fillWeightsForPoints(t, i), this.gw = t, i } Rw() { if (0 === this.mw.size) return null; let t = 0; return this.mw.forEach((i => { 0 !== i.length && (t = Math.max(t, i[i.length - 1].Re)) })), t } Cw(t, i, n) { const s = { wo: new Map, At: { q_: this.Rw() } }; if (-1 !== i) this.mw.forEach(((i, e) => { s.wo.set(e, { ne: i, Dw: e === t ? n : void 0 }) })), this.mw.has(t) || s.wo.set(t, { ne: [], Dw: n }), s.At.Ew = this.gw, s.At.Iw = i; else { const i = this.mw.get(t); s.wo.set(t, { ne: i || [], Dw: n }) } return s } } function es(t, i) { t.Re = i, t.cw.forEach((t => { t.Re = i })) } function rs(t, i) { return t.wt < i } function hs(t, i) { return i < t.wt } function as(t, i, n) { const s = i.Uh(), e = i.bi(), r = bt(t, s, rs), h = xt(t, e, hs); if (!n) return { from: r, to: h }; let a = r, l = h; return r > 0 && r < t.length && t[r].wt >= s && (a = r - 1), h > 0 && h < t.length && t[h - 1].wt <= e && (l = h + 1), { from: a, to: l } } class ls { constructor(t, i, n) { this.Vw = !0, this.Aw = !0, this.Bw = !0, this.zw = [], this.Ow = null, this.Js = t, this.Qs = i, this.Lw = n } kt(t) { this.Vw = !0, "data" === t && (this.Aw = !0), "options" === t && (this.Bw = !0) } Tt() { return this.Js.Et() ? (this.Nw(), null === this.Ow ? null : this.Ww) : null } Fw() { this.zw = this.zw.map((t => ({ ...t, ...this.Js.Rh().Dr(t.wt) }))) } Hw() { this.Ow = null } Nw() { this.Aw && (this.Uw(), this.Aw = !1), this.Bw && (this.Fw(), this.Bw = !1), this.Vw && (this.$w(), this.Vw = !1) } $w() { const t = this.Js.Wt(), i = this.Qs.At(); if (this.Hw(), i.Zi() || t.Zi()) return; const n = i.ye(); if (null === n) return; if (0 === this.Js.Yn().zr()) return; const s = this.Js.zt(); null !== s && (this.Ow = as(this.zw, n, this.Lw), this.jw(t, i, s.Ft), this.qw()) } } class os { constructor(t, i) { this.Yw = t, this.qi = i } st(t, i, n) { this.Yw.draw(t, this.qi, i, n) } } class _s extends ls { constructor(t, i, n) { super(t, i, !1), this.nh = n, this.Ww = new os(this.nh.renderer(), (i => { const n = t.zt(); return null === n ? null : t.Wt().Nt(i, n.Ft) })) } fa(t) { return this.nh.priceValueBuilder(t) } va(t) { return this.nh.isWhitespace(t) } Uw() { const t = this.Js.Rh(); this.zw = this.Js.Yn().Hr().map((i => ({ wt: i.Re, _t: NaN, ...t.Dr(i.Re), Zw: i.ne }))) } jw(t, i) { i.Y_(this.zw, m(this.Ow)) } qw() { this.nh.update({ bars: this.zw.map(us), barSpacing: this.Qs.At().Q_(), visibleRange: this.Ow }, this.Js.N()) } } function us(t) { return { x: t._t, time: t.wt, originalData: t.Zw, barColor: t.cr } } const cs = { color: "#2196f3" }, ds = (t, i, n) => { const s = l(n); return new _s(t, i, s) }; function fs(t) { const i = { value: t.Ft[3], time: t.ew }; return void 0 !== t.uw && (i.customValues = t.uw), i } function ps(t) { const i = fs(t); return void 0 !== t.R && (i.color = t.R), i } function vs(t) { const i = fs(t); return void 0 !== t.vt && (i.lineColor = t.vt), void 0 !== t.mr && (i.topColor = t.mr), void 0 !== t.wr && (i.bottomColor = t.wr), i } function ms(t) { const i = fs(t); return void 0 !== t.gr && (i.topLineColor = t.gr), void 0 !== t.Mr && (i.bottomLineColor = t.Mr), void 0 !== t.br && (i.topFillColor1 = t.br), void 0 !== t.Sr && (i.topFillColor2 = t.Sr), void 0 !== t.Cr && (i.bottomFillColor1 = t.Cr), void 0 !== t.yr && (i.bottomFillColor2 = t.yr), i } function ws(t) { const i = { open: t.Ft[0], high: t.Ft[1], low: t.Ft[2], close: t.Ft[3], time: t.ew }; return void 0 !== t.uw && (i.customValues = t.uw), i } function gs(t) { const i = ws(t); return void 0 !== t.R && (i.color = t.R), i } function Ms(t) { const i = ws(t), { R: n, Ht: s, vr: e } = t; return void 0 !== n && (i.color = n), void 0 !== s && (i.borderColor = s), void 0 !== e && (i.wickColor = e), i } function bs(t) { return { Area: vs, Line: ps, Baseline: ms, Histogram: ps, Bar: gs, Candlestick: Ms, Custom: xs }[t] } function xs(t) { const i = t.ew; return { ...t.ne, time: i } } const Ss = { vertLine: { color: "#9598A1", width: 1, style: 3, visible: !0, labelVisible: !0, labelBackgroundColor: "#131722" }, horzLine: { color: "#9598A1", width: 1, style: 3, visible: !0, labelVisible: !0, labelBackgroundColor: "#131722" }, mode: 1 }, Cs = { vertLines: { color: "#D6DCDE", style: 0, visible: !0 }, horzLines: { color: "#D6DCDE", style: 0, visible: !0 } }, ys = { background: { type: "solid", color: "#FFFFFF" }, textColor: "#191919", fontSize: 12, fontFamily: w, panes: { enableResize: !0, separatorColor: "#E0E3EB", separatorHoverColor: "rgba(178, 181, 189, 0.2)" }, attributionLogo: !0, colorSpace: "srgb", colorParsers: [] }, ks = { autoScale: !0, mode: 0, invertScale: !1, alignLabels: !0, borderVisible: !0, borderColor: "#2B2B43", entireTextOnly: !1, visible: !1, ticksVisible: !1, scaleMargins: { bottom: .1, top: .2 }, minimumWidth: 0 }, Ps = { rightOffset: 0, barSpacing: 6, minBarSpacing: .5, maxBarSpacing: 0, fixLeftEdge: !1, fixRightEdge: !1, lockVisibleTimeRangeOnResize: !1, rightBarStaysOnScroll: !1, borderVisible: !0, borderColor: "#2B2B43", visible: !0, timeVisible: !1, secondsVisible: !0, shiftVisibleRangeOnNewBar: !0, allowShiftVisibleRangeOnWhitespaceReplacement: !1, ticksVisible: !1, uniformDistribution: !1, minimumHeight: 0, allowBoldLabels: !0, ignoreWhitespaceIndices: !1 }; function Ts() { return { width: 0, height: 0, autoSize: !1, layout: ys, crosshair: Ss, grid: Cs, overlayPriceScales: { ...ks }, leftPriceScale: { ...ks, visible: !1 }, rightPriceScale: { ...ks, visible: !0 }, timeScale: Ps, localization: { locale: en ? navigator.language : "", dateFormat: "dd MMM 'yy" }, handleScroll: { mouseWheel: !0, pressedMouseMove: !0, horzTouchDrag: !0, vertTouchDrag: !0 }, handleScale: { axisPressedMouseMove: { time: !0, price: !0 }, axisDoubleClickReset: { time: !0, price: !0 }, mouseWheel: !0, pinch: !0 }, kineticScroll: { mouse: !1, touch: !0 }, trackingMode: { exitMode: 1 } } } class Rs { constructor(t, i, n) { this.bf = t, this.Kw = i, this.Xw = n ?? 0 } applyOptions(t) { this.bf.Qt().$u(this.Kw, t, this.Xw) } options() { return this.qi().N() } width() { return q(this.Kw) ? this.bf.Hm(this.Kw) : 0 } qi() { return a(this.bf.Qt().ju(this.Kw, this.Xw)).Wt } } class Ds { constructor(t, i, n, s) { this.bf = t, this.yt = n, this.Gw = i, this.Jw = s } getHeight() { return this.yt.$t() } setHeight(t) { const i = this.bf.Qt(), n = i.Cc(this.yt); i.Xu(n, t) } paneIndex() { return this.bf.Qt().Cc(this.yt) } moveTo(t) { const i = this.paneIndex(); i !== t && (r(t >= 0 && t < this.bf.Sf().length, "Invalid pane index"), this.bf.Qt().Gu(i, t)) } getSeries() { return this.yt.wo().map((t => this.Gw(t))) ?? [] } getHTMLElement() { return this.bf.Sf()[this.paneIndex()].Rf() } attachPrimitive(t) { this.yt.ua(t), t.attached && t.attached({ chart: this.Jw, requestUpdate: () => this.yt.Qt().Vh() }) } detachPrimitive(t) { this.yt.ca(t) } priceScale(t) { if (null === this.yt.co(t)) throw new Error(`Cannot find price scale with id: ${t}`); return new Rs(this.bf, t, this.paneIndex()) } } const Es = { color: "#FF0000", price: 0, lineStyle: 2, lineWidth: 1, lineVisible: !0, axisLabelVisible: !0, title: "", axisLabelColor: "", axisLabelTextColor: "" }; class Is { constructor(t) { this.ir = t } applyOptions(t) { this.ir.hr(t) } options() { return this.ir.N() } Qw() { return this.ir } } class Vs { constructor(t, i, n, s, e, r) { this.tg = new o, this.Js = t, this.ig = i, this.ng = n, this.qo = e, this.Jw = s, this.sg = r } m() { this.tg.m() } priceFormatter() { return this.Js.ra() } priceToCoordinate(t) { const i = this.Js.zt(); return null === i ? null : this.Js.Wt().Nt(t, i.Ft) } coordinateToPrice(t) { const i = this.Js.zt(); return null === i ? null : this.Js.Wt().kn(t, i.Ft) } barsInLogicalRange(t) { if (null === t) return null; const i = new Si(new Mi(t.from, t.to)).o_(), n = this.Js.Yn(); if (n.Zi()) return null; const s = n.Wr(i.Uh(), 1), e = n.Wr(i.bi(), -1), r = a(n.Or()), h = a(n.qn()); if (null !== s && null !== e && s.Re > e.Re) return { barsBefore: t.from - r, barsAfter: h - t.to }; const l = { barsBefore: null === s || s.Re === r ? t.from - r : s.Re - r, barsAfter: null === e || e.Re === h ? h - t.to : h - e.Re }; return null !== s && null !== e && (l.from = s.ew, l.to = e.ew), l } setData(t) { this.qo, this.Js.Rr(), this.ig.eg(this.Js, t), this.rg("full") } update(t, i = !1) { this.Js.Rr(), this.ig.hg(this.Js, t, i), this.rg("update") } dataByIndex(t, i) { const n = this.Js.Yn().Wr(t, i); if (null === n) return null; return bs(this.seriesType())(n) } data() { const t = bs(this.seriesType()); return this.Js.Yn().Hr().map((i => t(i))) } subscribeDataChanged(t) { this.tg.i(t) } unsubscribeDataChanged(t) { this.tg._(t) } applyOptions(t) { this.Js.hr(t) } options() { return p(this.Js.N()) } priceScale() { return this.ng.priceScale(this.Js.Wt().wa(), this.getPane().paneIndex()) } createPriceLine(t) { const i = _(p(Es), t), n = this.Js.Lh(i); return new Is(n) } removePriceLine(t) { this.Js.Nh(t.Qw()) } priceLines() { return this.Js.Wh().map((t => new Is(t))) } seriesType() { return this.Js.Rr() } attachPrimitive(t) { this.Js.ua(t), t.attached && t.attached({ chart: this.Jw, series: this, requestUpdate: () => this.Js.Qt().Vh(), horzScaleBehavior: this.qo }) } detachPrimitive(t) { this.Js.ca(t), t.detached && t.detached(), this.Js.Qt().Vh() } getPane() { const t = this.Js, i = a(this.Js.Qt().Hs(t)); return this.sg(i) } moveToPane(t) { this.Js.Qt().Mc(this.Js, t) } rg(t) { this.tg.v() && this.tg.p(t) } } class As { constructor(t, i, n) { this.ag = new o, this.g_ = new o, this.Kv = new o, this.tn = t, this.uh = t.At(), this.Rm = i, this.uh.du().i(this.lg.bind(this)), this.uh.fu().i(this.og.bind(this)), this.Rm.nm().i(this._g.bind(this)), this.qo = n } m() { this.uh.du().u(this), this.uh.fu().u(this), this.Rm.nm().u(this), this.ag.m(), this.g_.m(), this.Kv.m() } scrollPosition() { return this.uh.iu() } scrollToPosition(t, i) { i ? this.uh._u(t, 1e3) : this.tn.ds(t) } scrollToRealTime() { this.uh.ou() } getVisibleRange() { const t = this.uh.L_(); return null === t ? null : { from: t.from.originalTime, to: t.to.originalTime } } setVisibleRange(t) { const i = { from: this.qo.convertHorzItemToInternal(t.from), to: this.qo.convertHorzItemToInternal(t.to) }, n = this.uh.H_(i); this.tn.wc(n) } getVisibleLogicalRange() { const t = this.uh.O_(); return null === t ? null : { from: t.Uh(), to: t.bi() } } setVisibleLogicalRange(t) { r(t.from <= t.to, "The from index cannot be after the to index."), this.tn.wc(t) } resetTimeScale() { this.tn.us() } fitContent() { this.tn.mu() } logicalToCoordinate(t) { const i = this.tn.At(); return i.Zi() ? null : i.jt(t) } coordinateToLogical(t) { return this.uh.Zi() ? null : this.uh.Z_(t) } timeToIndex(t, i) { const n = this.qo.convertHorzItemToInternal(t); return this.uh.A_(n, i) } timeToCoordinate(t) { const i = this.timeToIndex(t, !1); return null === i ? null : this.uh.jt(i) } coordinateToTime(t) { const i = this.tn.At(), n = i.Z_(t), s = i.nn(n); return null === s ? null : s.originalTime } width() { return this.Rm.Df().width } height() { return this.Rm.Df().height } subscribeVisibleTimeRangeChange(t) { this.ag.i(t) } unsubscribeVisibleTimeRangeChange(t) { this.ag._(t) } subscribeVisibleLogicalRangeChange(t) { this.g_.i(t) } unsubscribeVisibleLogicalRangeChange(t) { this.g_._(t) } subscribeSizeChange(t) { this.Kv.i(t) } unsubscribeSizeChange(t) { this.Kv._(t) } applyOptions(t) { this.uh.hr(t) } options() { return { ...p(this.uh.N()), barSpacing: this.uh.Q_() } } lg() { this.ag.v() && this.ag.p(this.getVisibleRange()) } og() { this.g_.v() && this.g_.p(this.getVisibleLogicalRange()) } _g(t) { this.Kv.p(t.width, t.height) } } function Bs(t) { if (void 0 === t || "custom" === t.type) return; const i = t; void 0 !== i.minMove && void 0 === i.precision && (i.precision = function (t) { if (t >= 1) return 0; let i = 0; for (; i < 8; i++) { const n = Math.round(t); if (Math.abs(n - t) < 1e-8) return i; t *= 10 } return i }(i.minMove)) } function zs(t) { return function (t) { if (f(t.handleScale)) { const i = t.handleScale; t.handleScale = { axisDoubleClickReset: { time: i, price: i }, axisPressedMouseMove: { time: i, price: i }, mouseWheel: i, pinch: i } } else if (void 0 !== t.handleScale) { const { axisPressedMouseMove: i, axisDoubleClickReset: n } = t.handleScale; f(i) && (t.handleScale.axisPressedMouseMove = { time: i, price: i }), f(n) && (t.handleScale.axisDoubleClickReset = { time: n, price: n }) } const i = t.handleScroll; f(i) && (t.handleScroll = { horzTouchDrag: i, vertTouchDrag: i, mouseWheel: i, pressedMouseMove: i }) }(t), t } class Os { constructor(t, i, n) { this.ug = new Map, this.cg = new Map, this.dg = new o, this.fg = new o, this.pg = new o, this.Pu = new WeakMap, this.vg = new ss(i); const s = void 0 === n ? p(Ts()) : _(p(Ts()), zs(n)); this.mg = i, this.bf = new Wn(t, s, i), this.bf.Tv().i((t => { this.dg.v() && this.dg.p(this.wg(t())) }), this), this.bf.Rv().i((t => { this.fg.v() && this.fg.p(this.wg(t())) }), this), this.bf.Yu().i((t => { this.pg.v() && this.pg.p(this.wg(t())) }), this); const e = this.bf.Qt(); this.gg = new As(e, this.bf.Am(), this.mg) } remove() { this.bf.Tv().u(this), this.bf.Rv().u(this), this.bf.Yu().u(this), this.gg.m(), this.bf.m(), this.ug.clear(), this.cg.clear(), this.dg.m(), this.fg.m(), this.pg.m(), this.vg.m() } resize(t, i, n) { this.autoSizeActive() || this.bf.Em(t, i, n) } addCustomSeries(t, i = {}, n = 0) { const s = (t => ({ type: "Custom", isBuiltIn: !1, defaultOptions: { ...cs, ...t.defaultOptions() }, Mg: ds, bg: t }))(l(t)); return this.xg(s, i, n) } addSeries(t, i = {}, n = 0) { return this.xg(t, i, n) } removeSeries(t) { const i = h(this.ug.get(t)), n = this.vg.vc(i); this.bf.Qt().vc(i), this.Sg(n), this.ug.delete(t), this.cg.delete(i) } eg(t, i) { this.Sg(this.vg.Mw(t, i)) } hg(t, i, n) { this.Sg(this.vg.kw(t, i, n)) } subscribeClick(t) { this.dg.i(t) } unsubscribeClick(t) { this.dg._(t) } subscribeCrosshairMove(t) { this.pg.i(t) } unsubscribeCrosshairMove(t) { this.pg._(t) } subscribeDblClick(t) { this.fg.i(t) } unsubscribeDblClick(t) { this.fg._(t) } priceScale(t, i = 0) { return new Rs(this.bf, t, i) } timeScale() { return this.gg } applyOptions(t) { this.bf.hr(zs(t)) } options() { return this.bf.N() } takeScreenshot() { return this.bf.Wm() } removePane(t) { this.bf.Qt().Ku(t) } swapPanes(t, i) { this.bf.Qt().Gu(t, i) } autoSizeActive() { return this.bf.jm() } chartElement() { return this.bf.Af() } panes() { return this.bf.Qt().Hn().map((t => this.Cg(t))) } paneSize(t = 0) { const i = this.bf.Zm(t); return { height: i.height, width: i.width } } setCrosshairPosition(t, i, n) { const s = this.ug.get(n); if (void 0 === s) return; const e = this.bf.Qt().Hs(s); null !== e && this.bf.Qt().oc(t, i, e) } clearCrosshairPosition() { this.bf.Qt()._c(!0) } horzBehaviour() { return this.mg } xg(i, n = {}, s = 0) { r(void 0 !== i.Mg), Bs(n.priceFormat), "Candlestick" === i.type && function (t) { void 0 !== t.borderColor && (t.borderUpColor = t.borderColor, t.borderDownColor = t.borderColor), void 0 !== t.wickColor && (t.wickUpColor = t.wickColor, t.wickDownColor = t.wickColor) }(n); const e = _(p(t), p(i.defaultOptions), n), h = i.Mg, a = new Ht(this.bf.Qt(), i.type, e, h, i.bg); this.bf.Qt().dc(a, s); const l = new Vs(a, this, this, this, this.mg, (t => this.Cg(t))); return this.ug.set(l, a), this.cg.set(a, l), l } Sg(t) { const i = this.bf.Qt(); i.uc(t.At.q_, t.At.Ew, t.At.Iw), t.wo.forEach(((t, i) => i.ht(t.ne, t.Dw))), i.At().R_(), i.J_() } yg(t) { return h(this.cg.get(t)) } wg(t) { const i = new Map; t.lw.forEach(((t, n) => { const s = n.Rr(), e = bs(s)(t); if ("Custom" !== s) r(Un(e)); else { const t = n.pa(); r(!t || !1 === t(e)) } i.set(this.yg(n), e) })); const n = void 0 !== t.aw && this.cg.has(t.aw) ? this.yg(t.aw) : void 0; return { time: t.ew, logical: t.Re, point: t.rw, paneIndex: t.hw, hoveredSeries: n, hoveredObjectId: t.ow, seriesData: i, sourceEvent: t._w } } Cg(t) { let i = this.Pu.get(t); return i || (i = new Ds(this.bf, (t => this.yg(t)), t, this), this.Pu.set(t, i)), i } } function Ls(t) { if (d(t)) { const i = document.getElementById(t); return r(null !== i, `Cannot find element in DOM with id=${t}`), i } return t } function Ns(t, i, n) { const s = Ls(t), e = new Os(s, i, n); return i.setOptions(e.options()), e } class Ws extends ls { constructor(t, i) { super(t, i, !0) } jw(t, i, n) { i.Y_(this.zw, m(this.Ow)), t.Dl(this.zw, n, m(this.Ow)) } kg(t, i) { return { wt: t, gt: i, _t: NaN, ut: NaN } } Uw() { const t = this.Js.Rh(); this.zw = this.Js.Yn().Hr().map((i => { const n = i.Ft[3]; return this.Pg(i.Re, n, t) })) } } function Fs(t, i, n, s, e, r, h) { if (0 === i.length || s.from >= i.length || s.to <= 0) return; const { context: a, horizontalPixelRatio: l, verticalPixelRatio: o } = t, _ = i[s.from]; let u = r(t, _), c = _; if (s.to - s.from < 2) { const i = e / 2; a.beginPath(); const n = { _t: _._t - i, ut: _.ut }, s = { _t: _._t + i, ut: _.ut }; a.moveTo(n._t * l, n.ut * o), a.lineTo(s._t * l, s.ut * o), h(t, u, n, s) } else { const e = (i, n) => { h(t, u, c, n), a.beginPath(), u = i, c = n }; let d = c; a.beginPath(), a.moveTo(_._t * l, _.ut * o); for (let h = s.from + 1; h < s.to; ++h) { d = i[h]; const s = r(t, d); switch (n) { case 0: a.lineTo(d._t * l, d.ut * o); break; case 1: a.lineTo(d._t * l, i[h - 1].ut * o), s !== u && (e(s, d), a.lineTo(d._t * l, i[h - 1].ut * o)), a.lineTo(d._t * l, d.ut * o); break; case 2: { const [t, n] = js(i, h - 1, h); a.bezierCurveTo(t._t * l, t.ut * o, n._t * l, n.ut * o, d._t * l, d.ut * o); break } }1 !== n && s !== u && (e(s, d), a.moveTo(d._t * l, d.ut * o)) } (c !== d || c === d && 1 === n) && h(t, u, c, d) } } const Hs = 6; function Us(t, i) { return { _t: t._t - i._t, ut: t.ut - i.ut } } function $s(t, i) { return { _t: t._t / i, ut: t.ut / i } } function js(t, i, n) { const s = Math.max(0, i - 1), e = Math.min(t.length - 1, n + 1); var r, h; return [(r = t[i], h = $s(Us(t[n], t[s]), Hs), { _t: r._t + h._t, ut: r.ut + h.ut }), Us(t[n], $s(Us(t[e], t[i]), Hs))] } function qs(t, i) { const n = t.context; n.strokeStyle = i, n.stroke() } class Ys extends y { constructor() { super(...arguments), this.rt = null } ht(t) { this.rt = t } et(t) { if (null === this.rt) return; const { ot: i, lt: n, Tg: e, Rg: r, ct: h, Kt: a, Dg: l } = this.rt; if (null === n) return; const o = t.context; o.lineCap = "butt", o.lineWidth = h * t.verticalPixelRatio, s(o, a), o.lineJoin = "round"; const _ = this.Eg.bind(this); void 0 !== r && Fs(t, i, r, n, e, _, qs), l && function (t, i, n, s, e) { if (s.to - s.from <= 0) return; const { horizontalPixelRatio: r, verticalPixelRatio: h, context: a } = t; let l = null; const o = Math.max(1, Math.floor(r)) % 2 / 2, _ = n * h + o; for (let n = s.to - 1; n >= s.from; --n) { const s = i[n]; if (s) { const i = e(t, s); i !== l && (a.beginPath(), null !== l && a.fill(), a.fillStyle = i, l = i); const n = Math.round(s._t * r) + o, u = s.ut * h; a.moveTo(n, u), a.arc(n, u, _, 0, 2 * Math.PI) } } a.fill() }(t, i, l, n, _) } } class Zs extends Ys { Eg(t, i) { return i.vt } } class Ks extends Ws { constructor() { super(...arguments), this.Ww = new Zs } Pg(t, i, n) { return { ...this.kg(t, i), ...n.Dr(t) } } qw() { const t = this.Js.N(), i = { ot: this.zw, Kt: t.lineStyle, Rg: t.lineVisible ? t.lineType : void 0, ct: t.lineWidth, Dg: t.pointMarkersVisible ? t.pointMarkersRadius || t.lineWidth / 2 + 2 : void 0, lt: this.Ow, Tg: this.Qs.At().Q_() }; this.Ww.ht(i) } } const Xs = { type: "Line", isBuiltIn: !0, defaultOptions: { color: "#2196f3", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, Mg: (t, i) => new Ks(t, i) }; function Gs(t, i) { return t.weight > i.weight ? t : i } class Js { constructor() { this.Ig = new o, this.Vg = function (t) { let i = !1; return function (...n) { i || (i = !0, queueMicrotask((() => { t(...n), i = !1 }))) } }((() => this.Ig.p(this.Ag))), this.Ag = 0 } Bg() { return this.Ig } m() { this.Ig.m() } options() { return this.Sn } setOptions(t) { this.Sn = t } preprocessData(t) { } updateFormatter(t) { this.Sn && (this.Sn.localization = t) } createConverterToInternalObj(t) { return this.Vg(), t => (t > this.Ag && (this.Ag = t), t) } key(t) { return t } cacheKey(t) { return t } convertHorzItemToInternal(t) { return t } formatHorzItem(t) { return this.zg(t) } formatTickmark(t) { return this.zg(t.time) } maxTickMarkWeight(t) { return t.reduce(Gs, t[0]).weight } fillWeightsForPoints(t, i) { for (let s = i; s < t.length; ++s)t[s].timeWeight = (n = t[s].time) % 120 == 0 ? 10 : n % 60 == 0 ? 9 : n % 36 == 0 ? 8 : n % 12 == 0 ? 7 : n % 6 == 0 ? 6 : n % 3 == 0 ? 5 : n % 1 == 0 ? 4 : 0; var n; this.Ag = t[t.length - 1].time, this.Vg() } zg(t) { if (this.Sn.localization?.timeFormatter) return this.Sn.localization.timeFormatter(t); if (t < 12) return `${t}M`; const i = Math.floor(t / 12), n = t % 12; return 0 === n ? `${i}Y` : `${i}Y${n}M` } } const Qs = { yieldCurve: { baseResolution: 1, minimumTimeRange: 120, startTimeRange: 0 }, timeScale: { ignoreWhitespaceIndices: !0 }, leftPriceScale: { visible: !0 }, rightPriceScale: { visible: !1 }, localization: { priceFormatter: t => t.toFixed(3) + "%" } }, te = { lastValueVisible: !1, priceLineVisible: !1 }; class ie extends Os { constructor(t, i) { const n = _(Qs, i || {}), s = new Js; super(t, s, n), s.setOptions(this.options()), this._initWhitespaceSeries() } addSeries(t, i = {}, n = 0) { if (t.isBuiltIn && !1 === ["Area", "Line"].includes(t.type)) throw new Error("Yield curve only support Area and Line series"); const s = { ...te, ...i }; return super.addSeries(t, s, n) } _initWhitespaceSeries() { const t = this.horzBehaviour(), i = this.addSeries(Xs); let n; function s(s) { const e = function (t, i) { return { le: Math.max(0, t.startTimeRange), oe: Math.max(0, t.minimumTimeRange, i || 0), Og: Math.max(1, t.baseResolution) } }(t.options().yieldCurve, s), r = (({ le: t, oe: i, Og: n }) => `${t}~${i}~${n}`)(e); r !== n && (n = r, i.setData(function ({ le: t, oe: i, Og: n }) { return Array.from({ length: Math.floor((i - t) / n) + 1 }, ((i, s) => ({ time: t + s * n }))) }(e))) } s(0), t.Bg().i(s) } } function ne(t, i) { return t.weight > i.weight ? t : i } class se { options() { return this.Sn } setOptions(t) { this.Sn = t } preprocessData(t) { } updateFormatter(t) { this.Sn && (this.Sn.localization = t) } createConverterToInternalObj(t) { return t => t } key(t) { return t } cacheKey(t) { return t } convertHorzItemToInternal(t) { return t } formatHorzItem(t) { return t.toFixed(this.Cs()) } formatTickmark(t, i) { return t.time.toFixed(this.Cs()) } maxTickMarkWeight(t) { return t.reduce(ne, t[0]).weight } fillWeightsForPoints(t, i) { for (let s = i; s < t.length; ++s)t[s].timeWeight = (n = t[s].time) === 100 * Math.ceil(n / 100) ? 8 : n === 50 * Math.ceil(n / 50) ? 7 : n === 25 * Math.ceil(n / 25) ? 6 : n === 10 * Math.ceil(n / 10) ? 5 : n === 5 * Math.ceil(n / 5) ? 4 : n === Math.ceil(n) ? 3 : 2 * n === Math.ceil(2 * n) ? 1 : 0; var n } Cs() { return this.Sn.localization.precision } } function ee(t, i, n, s, e) { const { context: r, horizontalPixelRatio: h, verticalPixelRatio: a } = i; r.lineTo(e._t * h, t * a), r.lineTo(s._t * h, t * a), r.closePath(), r.fillStyle = n, r.fill() } class re extends y { constructor() { super(...arguments), this.rt = null } ht(t) { this.rt = t } et(t) { if (null === this.rt) return; const { ot: i, lt: n, Tg: e, ct: r, Kt: h, Rg: a } = this.rt, l = this.rt.Lg ?? (this.rt.Ng ? 0 : t.mediaSize.height); if (null === n) return; const o = t.context; o.lineCap = "butt", o.lineJoin = "round", o.lineWidth = r, s(o, h), o.lineWidth = 1, Fs(t, i, a, n, e, this.Wg.bind(this), ee.bind(null, l)) } } class he { Fg(t, i) { const n = this.Hg, { Ug: s, $g: e, jg: r, qg: h, Lg: a, Yg: l, Zg: o } = i; if (void 0 === this.Kg || void 0 === n || n.Ug !== s || n.$g !== e || n.jg !== r || n.qg !== h || n.Lg !== a || n.Yg !== l || n.Zg !== o) { const { verticalPixelRatio: n } = t, _ = a || l > 0 ? n : 1, u = l * _, c = o === t.bitmapSize.height ? o : o * _, d = (a ?? 0) * _, f = t.context.createLinearGradient(0, u, 0, c); if (f.addColorStop(0, s), null != a) { const t = si((d - u) / (c - u), 0, 1); f.addColorStop(t, e), f.addColorStop(t, r) } f.addColorStop(1, h), this.Kg = f, this.Hg = i } return this.Kg } } class ae extends re { constructor() { super(...arguments), this.Xg = new he } Wg(t, i) { const n = this.rt; return this.Xg.Fg(t, { Ug: i.br, $g: i.Sr, jg: i.Cr, qg: i.yr, Lg: n.Lg, Yg: n.Yg ?? 0, Zg: n.Zg ?? t.bitmapSize.height }) } } class le extends Ys { constructor() { super(...arguments), this.Gg = new he } Eg(t, i) { const n = this.rt; return this.Gg.Fg(t, { Ug: i.gr, $g: i.gr, jg: i.Mr, qg: i.Mr, Lg: n.Lg, Yg: n.Yg ?? 0, Zg: n.Zg ?? t.bitmapSize.height }) } } class oe extends Ws { constructor(t, i) { super(t, i), this.Ww = new C, this.Jg = new ae, this.Qg = new le, this.Ww.nt([this.Jg, this.Qg]) } Pg(t, i, n) { return { ...this.kg(t, i), ...n.Dr(t) } } qw() { const t = this.Js.zt(); if (null === t) return; const i = this.Js.N(), n = this.Js.Wt().Nt(i.baseValue.price, t.Ft), s = this.Qs.At().Q_(); if (null === this.Ow || 0 === this.zw.length) return; let e, r; if (i.relativeGradient) { e = this.zw[this.Ow.from].ut, r = this.zw[this.Ow.from].ut; for (let t = this.Ow.from; t < this.Ow.to; t++) { const i = this.zw[t]; i.ut < e && (e = i.ut), i.ut > r && (r = i.ut) } } this.Jg.ht({ ot: this.zw, ct: i.lineWidth, Kt: i.lineStyle, Rg: i.lineType, Lg: n, Yg: e, Zg: r, Ng: !1, lt: this.Ow, Tg: s }), this.Qg.ht({ ot: this.zw, ct: i.lineWidth, Kt: i.lineStyle, Rg: i.lineVisible ? i.lineType : void 0, Dg: i.pointMarkersVisible ? i.pointMarkersRadius || i.lineWidth / 2 + 2 : void 0, Lg: n, Yg: e, Zg: r, lt: this.Ow, Tg: s }) } } const _e = { type: "Baseline", isBuiltIn: !0, defaultOptions: { baseValue: { type: "price", price: 0 }, relativeGradient: !1, topFillColor1: "rgba(38, 166, 154, 0.28)", topFillColor2: "rgba(38, 166, 154, 0.05)", topLineColor: "rgba(38, 166, 154, 1)", bottomFillColor1: "rgba(239, 83, 80, 0.05)", bottomFillColor2: "rgba(239, 83, 80, 0.28)", bottomLineColor: "rgba(239, 83, 80, 1)", lineWidth: 3, lineStyle: 0, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, Mg: (t, i) => new oe(t, i) }; class ue extends re { constructor() { super(...arguments), this.Xg = new he } Wg(t, i) { return this.Xg.Fg(t, { Ug: i.mr, $g: "", jg: "", qg: i.wr, Yg: this.rt?.Yg ?? 0, Zg: t.bitmapSize.height }) } } class ce extends Ws { constructor(t, i) { super(t, i), this.Ww = new C, this.tM = new ue, this.iM = new Zs, this.Ww.nt([this.tM, this.iM]) } Pg(t, i, n) { return { ...this.kg(t, i), ...n.Dr(t) } } qw() { const t = this.Js.N(); if (null === this.Ow || 0 === this.zw.length) return; let i; if (t.relativeGradient) { i = this.zw[this.Ow.from].ut; for (let t = this.Ow.from; t < this.Ow.to; t++) { const n = this.zw[t]; n.ut < i && (i = n.ut) } } this.tM.ht({ Rg: t.lineType, ot: this.zw, Kt: t.lineStyle, ct: t.lineWidth, Lg: null, Yg: i, Ng: t.invertFilledArea, lt: this.Ow, Tg: this.Qs.At().Q_() }), this.iM.ht({ Rg: t.lineVisible ? t.lineType : void 0, ot: this.zw, Kt: t.lineStyle, ct: t.lineWidth, lt: this.Ow, Tg: this.Qs.At().Q_(), Dg: t.pointMarkersVisible ? t.pointMarkersRadius || t.lineWidth / 2 + 2 : void 0 }) } } const de = { type: "Area", isBuiltIn: !0, defaultOptions: { topColor: "rgba( 46, 220, 135, 0.4)", bottomColor: "rgba( 40, 221, 100, 0)", invertFilledArea: !1, relativeGradient: !1, lineColor: "#33D778", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, Mg: (t, i) => new ce(t, i) }; class fe extends y { constructor() { super(...arguments), this.qt = null, this.nM = 0, this.sM = 0 } ht(t) { this.qt = t } et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: n }) { if (null === this.qt || 0 === this.qt.Yn.length || null === this.qt.lt) return; if (this.nM = this.eM(i), this.nM >= 2) { Math.max(1, Math.floor(i)) % 2 != this.nM % 2 && this.nM-- } this.sM = this.qt.rM ? Math.min(this.nM, Math.floor(i)) : this.nM; let s = null; const e = this.sM <= this.nM && this.qt.Q_ >= Math.floor(1.5 * i); for (let r = this.qt.lt.from; r < this.qt.lt.to; ++r) { const h = this.qt.Yn[r]; s !== h.cr && (t.fillStyle = h.cr, s = h.cr); const a = Math.floor(.5 * this.sM), l = Math.round(h._t * i), o = l - a, _ = this.sM, u = o + _ - 1, c = Math.min(h.Al, h.Bl), d = Math.max(h.Al, h.Bl), f = Math.round(c * n) - a, p = Math.round(d * n) + a, v = Math.max(p - f, this.sM); t.fillRect(o, f, _, v); const m = Math.ceil(1.5 * this.nM); if (e) { if (this.qt.hM) { const i = l - m; let s = Math.max(f, Math.round(h.Vl * n) - a), e = s + _ - 1; e > f + v - 1 && (e = f + v - 1, s = e - _ + 1), t.fillRect(i, s, o - i, e - s + 1) } const i = l + m; let s = Math.max(f, Math.round(h.zl * n) - a), e = s + _ - 1; e > f + v - 1 && (e = f + v - 1, s = e - _ + 1), t.fillRect(u + 1, s, i - u, e - s + 1) } } } eM(t) { const i = Math.floor(t); return Math.max(i, Math.floor(function (t, i) { return Math.floor(.3 * t * i) }(a(this.qt).Q_, t))) } } class pe extends ls { constructor(t, i) { super(t, i, !1) } jw(t, i, n) { i.Y_(this.zw, m(this.Ow)), t.Il(this.zw, n, m(this.Ow)) } aM(t, i, n) { return { wt: t, jh: i.Ft[0], qh: i.Ft[1], Yh: i.Ft[2], Zh: i.Ft[3], _t: NaN, Vl: NaN, Al: NaN, Bl: NaN, zl: NaN } } Uw() { const t = this.Js.Rh(); this.zw = this.Js.Yn().Hr().map((i => this.Pg(i.Re, i, t))) } } class ve extends pe { constructor() { super(...arguments), this.Ww = new fe } Pg(t, i, n) { return { ...this.aM(t, i, n), ...n.Dr(t) } } qw() { const t = this.Js.N(); this.Ww.ht({ Yn: this.zw, Q_: this.Qs.At().Q_(), hM: t.openVisible, rM: t.thinBars, lt: this.Ow }) } } const me = { type: "Bar", isBuiltIn: !0, defaultOptions: { upColor: "#26a69a", downColor: "#ef5350", openVisible: !0, thinBars: !0 }, Mg: (t, i) => new ve(t, i) }; class we extends y { constructor() { super(...arguments), this.qt = null, this.nM = 0 } ht(t) { this.qt = t } et(t) { if (null === this.qt || 0 === this.qt.Yn.length || null === this.qt.lt) return; const { horizontalPixelRatio: i } = t; if (this.nM = function (t, i) { if (t >= 2.5 && t <= 4) return Math.floor(3 * i); const n = 1 - .2 * Math.atan(Math.max(4, t) - 4) / (.5 * Math.PI), s = Math.floor(t * n * i), e = Math.floor(t * i), r = Math.min(s, e); return Math.max(Math.floor(i), r) }(this.qt.Q_, i), this.nM >= 2) { Math.floor(i) % 2 != this.nM % 2 && this.nM-- } const n = this.qt.Yn; this.qt.lM && this.oM(t, n, this.qt.lt), this.qt.Mi && this.$p(t, n, this.qt.lt); const s = this._M(i); (!this.qt.Mi || this.nM > 2 * s) && this.uM(t, n, this.qt.lt) } oM(t, i, n) { if (null === this.qt) return; const { context: s, horizontalPixelRatio: e, verticalPixelRatio: r } = t; let h = "", a = Math.min(Math.floor(e), Math.floor(this.qt.Q_ * e)); a = Math.max(Math.floor(e), Math.min(a, this.nM)); const l = Math.floor(.5 * a); let o = null; for (let t = n.from; t < n.to; t++) { const n = i[t]; n.pr !== h && (s.fillStyle = n.pr, h = n.pr); const _ = Math.round(Math.min(n.Vl, n.zl) * r), u = Math.round(Math.max(n.Vl, n.zl) * r), c = Math.round(n.Al * r), d = Math.round(n.Bl * r); let f = Math.round(e * n._t) - l; const p = f + a - 1; null !== o && (f = Math.max(o + 1, f), f = Math.min(f, p)); const v = p - f + 1; s.fillRect(f, c, v, _ - c), s.fillRect(f, u + 1, v, d - u), o = p } } _M(t) { let i = Math.floor(1 * t); this.nM <= 2 * i && (i = Math.floor(.5 * (this.nM - 1))); const n = Math.max(Math.floor(t), i); return this.nM <= 2 * n ? Math.max(Math.floor(t), Math.floor(1 * t)) : n } $p(t, i, n) { if (null === this.qt) return; const { context: s, horizontalPixelRatio: e, verticalPixelRatio: r } = t; let h = ""; const a = this._M(e); let l = null; for (let t = n.from; t < n.to; t++) { const n = i[t]; n.dr !== h && (s.fillStyle = n.dr, h = n.dr); let o = Math.round(n._t * e) - Math.floor(.5 * this.nM); const _ = o + this.nM - 1, u = Math.round(Math.min(n.Vl, n.zl) * r), c = Math.round(Math.max(n.Vl, n.zl) * r); if (null !== l && (o = Math.max(l + 1, o), o = Math.min(o, _)), this.qt.Q_ * e > 2 * a) I(s, o, u, _ - o + 1, c - u + 1, a); else { const t = _ - o + 1; s.fillRect(o, u, t, c - u + 1) } l = _ } } uM(t, i, n) { if (null === this.qt) return; const { context: s, horizontalPixelRatio: e, verticalPixelRatio: r } = t; let h = ""; const a = this._M(e); for (let t = n.from; t < n.to; t++) { const n = i[t]; let l = Math.round(Math.min(n.Vl, n.zl) * r), o = Math.round(Math.max(n.Vl, n.zl) * r), _ = Math.round(n._t * e) - Math.floor(.5 * this.nM), u = _ + this.nM - 1; if (n.cr !== h) { const t = n.cr; s.fillStyle = t, h = t } this.qt.Mi && (_ += a, l += a, u -= a, o -= a), l > o || s.fillRect(_, l, u - _ + 1, o - l + 1) } } } class ge extends pe { constructor() { super(...arguments), this.Ww = new we } Pg(t, i, n) { return { ...this.aM(t, i, n), ...n.Dr(t) } } qw() { const t = this.Js.N(); this.Ww.ht({ Yn: this.zw, Q_: this.Qs.At().Q_(), lM: t.wickVisible, Mi: t.borderVisible, lt: this.Ow }) } } const Me = { type: "Candlestick", isBuiltIn: !0, defaultOptions: { upColor: "#26a69a", downColor: "#ef5350", wickVisible: !0, borderVisible: !0, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, Mg: (t, i) => new ge(t, i) }; class be extends y { constructor() { super(...arguments), this.qt = null, this.cM = [] } ht(t) { this.qt = t, this.cM = [] } et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: n }) { if (null === this.qt || 0 === this.qt.ot.length || null === this.qt.lt) return; this.cM.length || this.dM(i); const s = Math.max(1, Math.floor(n)), e = Math.round(this.qt.fM * n) - Math.floor(s / 2), r = e + s; for (let i = this.qt.lt.from; i < this.qt.lt.to; i++) { const h = this.qt.ot[i], a = this.cM[i - this.qt.lt.from], l = Math.round(h.ut * n); let o, _; t.fillStyle = h.cr, l <= e ? (o = l, _ = r) : (o = e, _ = l - Math.floor(s / 2) + s), t.fillRect(a.Uh, o, a.bi - a.Uh + 1, _ - o) } } dM(t) { if (null === this.qt || 0 === this.qt.ot.length || null === this.qt.lt) return void (this.cM = []); const i = Math.ceil(this.qt.Q_ * t) <= 1 ? 0 : Math.max(1, Math.floor(t)), n = Math.round(this.qt.Q_ * t) - i; this.cM = new Array(this.qt.lt.to - this.qt.lt.from); for (let i = this.qt.lt.from; i < this.qt.lt.to; i++) { const s = this.qt.ot[i], e = Math.round(s._t * t); let r, h; if (n % 2) { const t = (n - 1) / 2; r = e - t, h = e + t } else { const t = n / 2; r = e - t, h = e + t - 1 } this.cM[i - this.qt.lt.from] = { Uh: r, bi: h, pM: e, se: s._t * t, wt: s.wt } } for (let t = this.qt.lt.from + 1; t < this.qt.lt.to; t++) { const n = this.cM[t - this.qt.lt.from], s = this.cM[t - this.qt.lt.from - 1]; n.wt === s.wt + 1 && (n.Uh - s.bi !== i + 1 && (s.pM > s.se ? s.bi = n.Uh - i - 1 : n.Uh = s.bi + i + 1)) } let s = Math.ceil(this.qt.Q_ * t); for (let t = this.qt.lt.from; t < this.qt.lt.to; t++) { const i = this.cM[t - this.qt.lt.from]; i.bi < i.Uh && (i.bi = i.Uh); const n = i.bi - i.Uh + 1; s = Math.min(n, s) } if (i > 0 && s < 4) for (let t = this.qt.lt.from; t < this.qt.lt.to; t++) { const i = this.cM[t - this.qt.lt.from]; i.bi - i.Uh + 1 > s && (i.pM > i.se ? i.bi -= 1 : i.Uh += 1) } } } class xe extends Ws { constructor() { super(...arguments), this.Ww = new be } Pg(t, i, n) { return { ...this.kg(t, i), ...n.Dr(t) } } qw() { const t = { ot: this.zw, Q_: this.Qs.At().Q_(), lt: this.Ow, fM: this.Js.Wt().Nt(this.Js.N().base, a(this.Js.zt()).Ft) }; this.Ww.ht(t) } } const Se = { type: "Histogram", isBuiltIn: !0, defaultOptions: { color: "#26a69a", base: 0 }, Mg: (t, i) => new xe(t, i) }; class Ce { constructor(t, i) { this.yt = t, this.vM = i, this.mM() } detach() { this.yt.detachPrimitive(this.vM) } getPane() { return this.yt } applyOptions(t) { this.vM.hr?.(t) } mM() { this.yt.attachPrimitive(this.vM) } } const ye = { visible: !0, horzAlign: "center", vertAlign: "center", lines: [] }, ke = { color: "rgba(0, 0, 0, 0.5)", fontSize: 48, fontFamily: w, fontStyle: "", text: "" }; class Pe { constructor(t) { this.wM = new Map, this.qt = t } draw(t) { t.useMediaCoordinateSpace((t => { if (!this.qt.visible) return; const { context: i, mediaSize: n } = t; let s = 0; for (const t of this.qt.lines) { if (0 === t.text.length) continue; i.font = t.P; const e = this.gM(i, t.text); e > n.width ? t.hu = n.width / e : t.hu = 1, s += t.lineHeight * t.hu } let e = 0; switch (this.qt.vertAlign) { case "top": e = 0; break; case "center": e = Math.max((n.height - s) / 2, 0); break; case "bottom": e = Math.max(n.height - s, 0) }for (const t of this.qt.lines) { i.save(), i.fillStyle = t.color; let s = 0; switch (this.qt.horzAlign) { case "left": i.textAlign = "left", s = t.lineHeight / 2; break; case "center": i.textAlign = "center", s = n.width / 2; break; case "right": i.textAlign = "right", s = n.width - 1 - t.lineHeight / 2 }i.translate(s, e), i.textBaseline = "top", i.font = t.P, i.scale(t.hu, t.hu), i.fillText(t.text, 0, t.MM), i.restore(), e += t.lineHeight * t.hu } })) } gM(t, i) { const n = this.bM(t.font); let s = n.get(i); return void 0 === s && (s = t.measureText(i).width, n.set(i, s)), s } bM(t) { let i = this.wM.get(t); return void 0 === i && (i = new Map, this.wM.set(t, i)), i } } class Te { constructor(t) { this.Sn = De(t) } kt(t) { this.Sn = De(t) } renderer() { return new Pe(this.Sn) } } function Re(t) { return { ...t, P: g(t.fontSize, t.fontFamily, t.fontStyle), lineHeight: t.lineHeight || 1.2 * t.fontSize, MM: 0, hu: 0 } } function De(t) { return { ...t, lines: t.lines.map(Re) } } function Ee(t) { return { ...ke, ...t } } function Ie(t) { return { ...ye, ...t, lines: t.lines?.map(Ee) ?? [] } } class Ve { constructor(t) { this.Sn = Ie(t), this.xM = [new Te(this.Sn)] } updateAllViews() { this.xM.forEach((t => t.kt(this.Sn))) } paneViews() { return this.xM } attached({ requestUpdate: t }) { this.SM = t } detached() { this.SM = void 0 } hr(t) { this.Sn = Ie({ ...this.Sn, ...t }), this.SM && this.SM() } } const Ae = { alpha: 1, padding: 0 }; class Be { constructor(t) { this.qt = t } draw(t) { t.useMediaCoordinateSpace((t => { const i = t.context, n = this.CM(this.qt, t.mediaSize); n && this.qt.yM && (i.globalAlpha = this.qt.alpha ?? 1, i.drawImage(this.qt.yM, n._t, n.ut, n.Qi, n.$t)) })) } CM(t, i) { const { maxHeight: n, maxWidth: s, kM: e, PM: r, padding: h } = t, a = Math.round(i.width / 2), l = Math.round(i.height / 2), o = h ?? 0; let _ = i.width - 2 * o, u = i.height - 2 * o; n && (u = Math.min(u, n)), s && (_ = Math.min(_, s)); const c = _ / r, d = u / e, f = Math.min(c, d), p = r * f, v = e * f; return { _t: a - .5 * p, ut: l - .5 * v, $t: v, Qi: p } } } class ze { constructor(t) { this.TM = null, this.RM = 0, this.DM = 0, this.Sn = t, this.M = Oe(this.Sn, this.TM, this.RM, this.DM) } EM(t) { void 0 !== t.IM && (this.RM = t.IM), void 0 !== t.VM && (this.DM = t.VM), void 0 !== t.AM && (this.TM = t.AM), this.kt() } BM(t) { this.Sn = t, this.kt() } zOrder() { return "bottom" } kt() { this.M = Oe(this.Sn, this.TM, this.RM, this.DM) } renderer() { return new Be(this.M) } } function Oe(t, i, n, s) { return { ...t, yM: i, PM: n, kM: s } } function Le(t) { return { ...Ae, ...t } } class Ne { constructor(t, i) { this.zM = null, this.OM = t, this.Sn = Le(i), this.xM = [new ze(this.Sn)] } updateAllViews() { this.xM.forEach((t => t.kt())) } paneViews() { return this.xM } attached(t) { const { requestUpdate: i } = t; this.LM = i, this.zM = new Image, this.zM.onload = () => { const t = this.zM?.naturalHeight ?? 1, i = this.zM?.naturalWidth ?? 1; this.xM.forEach((n => n.EM({ VM: t, IM: i, AM: this.zM }))), this.LM && this.LM() }, this.zM.src = this.OM } detached() { this.LM = void 0, this.zM = null } hr(t) { this.Sn = Le({ ...this.Sn, ...t }), this.NM(), this.SM && this.SM() } SM() { this.LM && this.LM() } NM() { this.xM.forEach((t => t.BM(this.Sn))) } } class We { constructor(t, i) { this.Js = t, this.ah = i, this.mM() } detach() { this.Js.detachPrimitive(this.ah) } getSeries() { return this.Js } applyOptions(t) { this.ah && this.ah.hr && this.ah.hr(t) } mM() { this.Js.attachPrimitive(this.ah) } } function Fe(t, i) { return ri(Math.min(Math.max(t, 12), 30) * i) } function He(t, i) { switch (t) { case "arrowDown": case "arrowUp": return Fe(i, 1); case "circle": return Fe(i, .8); case "square": return Fe(i, .7) } } function Ue(t) { return function (t) { const i = Math.ceil(t); return i % 2 != 0 ? i - 1 : i }(Fe(t, 1)) } function $e(t) { return Math.max(Fe(t, .1), 3) } function je(t, i, n) { return i ? t : n ? Math.ceil(t / 2) : 0 } function qe(t, i, n, s) { const e = (He("arrowUp", s) - 1) / 2 * n.WM, r = (ri(s / 2) - 1) / 2 * n.WM; i.beginPath(), t ? (i.moveTo(n._t - e, n.ut), i.lineTo(n._t, n.ut - e), i.lineTo(n._t + e, n.ut), i.lineTo(n._t + r, n.ut), i.lineTo(n._t + r, n.ut + e), i.lineTo(n._t - r, n.ut + e), i.lineTo(n._t - r, n.ut)) : (i.moveTo(n._t - e, n.ut), i.lineTo(n._t, n.ut + e), i.lineTo(n._t + e, n.ut), i.lineTo(n._t + r, n.ut), i.lineTo(n._t + r, n.ut - e), i.lineTo(n._t - r, n.ut - e), i.lineTo(n._t - r, n.ut)), i.fill() } function Ye(t, i, n, s, e, r) { const h = (He("arrowUp", s) - 1) / 2, a = (ri(s / 2) - 1) / 2; if (e >= i - a - 2 && e <= i + a + 2 && r >= (t ? n : n - h) - 2 && r <= (t ? n + h : n) + 2) return !0; return (() => { if (e < i - h - 3 || e > i + h + 3 || r < (t ? n - h - 3 : n) || r > (t ? n : n + h + 3)) return !1; const s = Math.abs(e - i); return Math.abs(r - n) + 3 >= s / 2 })() } class Ze { constructor() { this.qt = null, this.Ls = new tt, this.W = -1, this.F = "", this.Mp = "" } ht(t) { this.qt = t } Ns(t, i) { this.W === t && this.F === i || (this.W = t, this.F = i, this.Mp = g(t, i), this.Ls.Is()) } Ys(t, i) { if (null === this.qt || null === this.qt.lt) return null; for (let n = this.qt.lt.from; n < this.qt.lt.to; n++) { const s = this.qt.ot[n]; if (s && Xe(s, t, i)) return { zOrder: "normal", externalId: s.Zs ?? "" } } return null } draw(t) { t.useBitmapCoordinateSpace((t => { this.et(t) })) } et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: n }) { if (null !== this.qt && null !== this.qt.lt) { t.textBaseline = "middle", t.font = this.Mp; for (let s = this.qt.lt.from; s < this.qt.lt.to; s++) { const e = this.qt.ot[s]; void 0 !== e.ri && (e.ri.Qi = this.Ls.Ei(t, e.ri.FM), e.ri.$t = this.W, e.ri._t = e._t - e.ri.Qi / 2), Ke(e, t, i, n) } } } } function Ke(t, i, n, s) { i.fillStyle = t.R, void 0 !== t.ri && function (t, i, n, s, e, r) { t.save(), t.scale(e, r), t.fillText(i, n, s), t.restore() }(i, t.ri.FM, t.ri._t, t.ri.ut, n, s), function (t, i, n) { if (0 === t.zr) return; switch (t.HM) { case "arrowDown": return void qe(!1, i, n, t.zr); case "arrowUp": return void qe(!0, i, n, t.zr); case "circle": return void function (t, i, n) { const s = (He("circle", n) - 1) / 2; t.beginPath(), t.arc(i._t, i.ut, s * i.WM, 0, 2 * Math.PI, !1), t.fill() }(i, n, t.zr); case "square": return void function (t, i, n) { const s = He("square", n), e = (s - 1) * i.WM / 2, r = i._t - e, h = i.ut - e; t.fillRect(r, h, s * i.WM, s * i.WM) }(i, n, t.zr) }t.HM }(t, i, function (t, i, n) { const s = Math.max(1, Math.floor(i)) % 2 / 2; return { _t: Math.round(t._t * i) + s, ut: t.ut * n, WM: i } }(t, n, s)) } function Xe(t, i, n) { return !(void 0 === t.ri || !function (t, i, n, s, e, r) { const h = s / 2; return e >= t && e <= t + n && r >= i - h && r <= i + h }(t.ri._t, t.ri.ut, t.ri.Qi, t.ri.$t, i, n)) || function (t, i, n) { if (0 === t.zr) return !1; switch (t.HM) { case "arrowDown": return Ye(!0, t._t, t.ut, t.zr, i, n); case "arrowUp": return Ye(!1, t._t, t.ut, t.zr, i, n); case "circle": return function (t, i, n, s, e) { const r = 2 + He("circle", n) / 2, h = t - s, a = i - e; return Math.sqrt(h * h + a * a) <= r }(t._t, t.ut, t.zr, i, n); case "square": return function (t, i, n, s, e) { const r = He("square", n), h = (r - 1) / 2, a = t - h, l = i - h; return s >= a && s <= a + r && e >= l && e <= l + r }(t._t, t.ut, t.zr, i, n) } }(t, i, n) } function Ge(t, i, n, s, e, r, h, l) { const o = l.timeScale(); let _, c, d; if ("value" in (f = n) && "number" == typeof f.value) _ = n.value, c = n.value, d = n.value; else { if (!function (t) { return "open" in t && "high" in t && "low" in t && "close" in t }(n)) return; _ = n.close, c = n.high, d = n.low } var f; const p = u(i.size) ? Math.max(i.size, 0) : 1, v = Ue(o.options().barSpacing) * p, m = v / 2; switch (t.zr = v, i.position) { case "inBar": return t.ut = a(h.priceToCoordinate(_)), void (void 0 !== t.ri && (t.ri.ut = t.ut + m + r + .6 * e)); case "aboveBar": return t.ut = a(h.priceToCoordinate(c)) - m - s.UM, void 0 !== t.ri && (t.ri.ut = t.ut - m - .6 * e, s.UM += 1.2 * e), void (s.UM += v + r); case "belowBar": return t.ut = a(h.priceToCoordinate(d)) + m + s.$M, void 0 !== t.ri && (t.ri.ut = t.ut + m + r + .6 * e, s.$M += 1.2 * e), void (s.$M += v + r) }i.position } class Je { constructor(t, i) { this.jM = [], this.St = !0, this.qM = !0, this.Gt = new Ze, this.ge = t, this._p = i, this.qt = { ot: [], lt: null } } renderer() { if (!this.ge.options().visible) return null; this.St && this.YM(); const t = this._p.options().layout; return this.Gt.Ns(t.fontSize, t.fontFamily), this.Gt.ht(this.qt), this.Gt } ZM(t) { this.jM = t, this.kt("data") } kt(t) { this.St = !0, "data" === t && (this.qM = !0) } YM() { const t = this._p.timeScale(), i = this.jM; this.qM && (this.qt.ot = i.map((t => ({ wt: t.time, _t: 0, ut: 0, zr: 0, HM: t.shape, R: t.color, Zs: t.id, KM: t.KM, ri: void 0 }))), this.qM = !1); const n = this._p.options().layout; this.qt.lt = null; const s = t.getVisibleLogicalRange(); if (null === s) return; const e = new Mi(Math.floor(s.from), Math.ceil(s.to)); if (null === this.ge.data()[0]) return; if (0 === this.qt.ot.length) return; let r = NaN; const h = $e(t.options().barSpacing), l = { UM: h, $M: h }; this.qt.lt = as(this.qt.ot, e, !0); for (let s = this.qt.lt.from; s < this.qt.lt.to; s++) { const e = i[s]; e.time !== r && (l.UM = h, l.$M = h, r = e.time); const o = this.qt.ot[s]; o._t = a(t.logicalToCoordinate(e.time)), void 0 !== e.text && e.text.length > 0 && (o.ri = { FM: e.text, _t: 0, ut: 0, Qi: 0, $t: 0 }); const _ = a(this.ge.dataByIndex(e.time, -1)); null !== _ && Ge(o, e, _, l, n.fontSize, h, this.ge, this._p) } this.St = !1 } } class Qe { constructor() { this.nh = null, this.jM = [], this.XM = [], this.GM = null, this.ge = null, this._p = null, this.JM = !0, this.QM = null, this.tb = null, this.ib = null } attached(t) { this.nb(), this._p = t.chart, this.ge = t.series, this.nh = new Je(this.ge, a(this._p)), this.LM = t.requestUpdate, this.ge.subscribeDataChanged((t => this.rg(t))), this.SM() } SM() { this.LM && this.LM() } detached() { this.ge && this.GM && this.ge.unsubscribeDataChanged(this.GM), this._p = null, this.ge = null, this.nh = null, this.GM = null } ZM(t) { this.jM = t, this.nb(), this.JM = !0, this.tb = null, this.SM() } sb() { return this.jM } paneViews() { return this.nh ? [this.nh] : [] } updateAllViews() { this.eb() } hitTest(t, i) { return this.nh ? this.nh.renderer()?.Ys(t, i) ?? null : null } autoscaleInfo(t, i) { if (this.nh) { const t = this.rb(); if (t) return { priceRange: null, margins: t } } return null } rb() { const t = a(this._p).timeScale().options().barSpacing; if (this.JM || t !== this.ib) { if (this.ib = t, this.jM.length > 0) { const i = $e(t), n = 1.5 * Ue(t) + 2 * i, s = this.hb(); this.QM = { above: je(n, s.aboveBar, s.inBar), below: je(n, s.belowBar, s.inBar) } } else this.QM = null; this.JM = !1 } return this.QM } hb() { return null === this.tb && (this.tb = this.jM.reduce(((t, i) => (t[i.position] || (t[i.position] = !0), t)), { inBar: !1, aboveBar: !1, belowBar: !1 })), this.tb } nb() { if (!this._p || !this.ge) return; const t = this._p.timeScale(); if (null == t.getVisibleLogicalRange() || !this.ge || 0 === this.ge?.data().length) return void (this.XM = []); const i = this.ge?.data(), n = t.timeToIndex(a(i[0].time), !0); this.XM = this.jM.map(((i, s) => { const e = t.timeToIndex(i.time, !0), r = e < n ? 1 : -1, h = a(this.ge).dataByIndex(e, r); return { time: t.timeToIndex(a(h).time, !1), position: i.position, shape: i.shape, color: i.color, id: i.id, KM: s, text: i.text, size: i.size, ew: i.time } })) } eb(t) { this.nh && (this.nb(), this.nh.ZM(this.XM), this.nh.kt(t)) } rg(t) { this.SM() } } class tr extends We { constructor(t, i, n) { super(t, i), n && this.setMarkers(n) } setMarkers(t) { this.ah.ZM(t) } markers() { return this.ah.sb() } } class ir { constructor(t) { this.jM = new Map, this.ab = t } lb(t, i, n) { if (this.ob(i), void 0 !== n) { const s = window.setTimeout((() => { this.jM.delete(i), this._b() }), n), e = { ...t, ub: s, cb: Date.now() + n }; this.jM.set(i, e) } else this.jM.set(i, { ...t, ub: void 0, cb: void 0 }); this._b() } ob(t) { const i = this.jM.get(t); i && void 0 !== i.ub && window.clearTimeout(i.ub), this.jM.delete(t), this._b() } fb() { for (const [t] of this.jM) this.ob(t) } pb() { const t = Date.now(), i = []; for (const [n, s] of this.jM) !s.cb || s.cb > t ? i.push({ time: s.time, sign: s.sign, value: s.value }) : this.ob(n); return i } mb(t) { this.ab = t } _b() { this.ab && this.ab() } } const nr = { positiveColor: "#22AB94", negativeColor: "#F7525F", updateVisibilityDuration: 5e3 }; class sr { constructor(t, i, n, s) { this.qt = t, this.wb = i, this.gb = n, this.Mb = s } draw(t) { t.useBitmapCoordinateSpace((t => { const i = t.context, n = Math.max(1, Math.floor(t.horizontalPixelRatio)) % 2 / 2, s = 4 * t.verticalPixelRatio + n; this.qt.forEach((e => { const r = Math.round(e._t * t.horizontalPixelRatio) + n; i.beginPath(); const h = this.bb(e.xb); i.fillStyle = h, i.arc(r, e.ut * t.verticalPixelRatio, s, 0, 2 * Math.PI, !1), i.fill(), e.xb && (i.strokeStyle = h, i.lineWidth = Math.floor(2 * t.horizontalPixelRatio), i.beginPath(), i.moveTo((e._t - 4.7) * t.horizontalPixelRatio + n, (e.ut - 7 * e.xb) * t.verticalPixelRatio), i.lineTo(e._t * t.horizontalPixelRatio + n, (e.ut - 7 * e.xb - 7 * e.xb * .5) * t.verticalPixelRatio), i.lineTo((e._t + 4.7) * t.horizontalPixelRatio + n, (e.ut - 7 * e.xb) * t.verticalPixelRatio), i.stroke()) })) })) } bb(t) { return 0 === t ? this.wb : t > 0 ? this.Mb : this.gb } } class er { constructor(t, i, n) { this.qt = [], this.ge = t, this.uh = i, this.Sn = n } kt(t) { this.qt = t.map((t => { const i = this.ge.priceToCoordinate(t.value); if (null === i) return null; return { _t: a(this.uh.timeToCoordinate(t.time)), ut: i, xb: t.sign } })).filter(v) } renderer() { const t = function (t, i) { return function (t, i) { return "Area" === i }(0, i) ? t.lineColor : t.color }(this.ge.options(), this.ge.seriesType()); return new sr(this.qt, t, this.Sn.negativeColor, this.Sn.positiveColor) } } function rr(t, i) { return "Line" === i || "Area" === i } class hr { constructor(t) { this._p = void 0, this.ge = void 0, this.xM = [], this.qo = null, this.Sb = new Map, this.Cb = new ir((() => this.SM())), this.Sn = { ...nr, ...t } } hr(t) { this.Sn = { ...this.Sn, ...t }, this.SM() } ZM(t) { this.Cb.fb(); const i = this.qo; i && t.forEach((t => { this.Cb.lb(t, i.key(t.time)) })) } sb() { return this.Cb.pb() } SM() { this.LM?.() } attached(t) { const { chart: i, series: n, requestUpdate: s, horzScaleBehavior: e } = t; this._p = i, this.ge = n, this.qo = e; const r = this.ge.seriesType(); if ("Area" !== r && "Line" !== r) throw new Error("UpDownMarkersPrimitive is only supported for Area and Line series types"); this.xM = [new er(this.ge, this._p.timeScale(), this.Sn)], this.LM = s, this.SM() } detached() { this._p = void 0, this.ge = void 0, this.LM = void 0 } Cp() { return h(this._p) } wo() { return h(this.ge) } updateAllViews() { this.xM.forEach((t => t.kt(this.sb()))) } paneViews() { return this.xM } ht(t) { if (!this.ge) throw new Error("Primitive not attached to series"); const i = this.ge.seriesType(); this.Sb.clear(); const n = this.qo; n && t.forEach((t => { Un(t) && rr(0, i) && this.Sb.set(n.key(t.time), t.value) })), h(this.ge).setData(t) } kt(t, i) { if (!this.ge || !this.qo) throw new Error("Primitive not attached to series"); const n = this.ge.seriesType(), s = this.qo.key(t.time); if (Hn(t) && this.Sb.delete(s), Un(t) && rr(0, n)) { const i = this.Sb.get(s); i && this.Cb.lb({ time: t.time, value: t.value, sign: ar(t.value, i) }, s, this.Sn.updateVisibilityDuration) } h(this.ge).update(t, i) } yb() { this.Cb.fb() } } function ar(t, i) { return t === i ? 0 : t - i > 0 ? 1 : -1 } class lr extends We { setData(t) { return this.ah.ht(t) } update(t, i) { return this.ah.kt(t, i) } markers() { return this.ah.sb() } setMarkers(t) { return this.ah.ZM(t) } clearMarkers() { return this.ah.yb() } } const or = { ...t, color: "#2196f3" }; var _r = Object.freeze({ __proto__: null, AreaSeries: de, BarSeries: me, BaselineSeries: _e, CandlestickSeries: Me, get ColorType() { return Ri }, get CrosshairMode() { return $ }, HistogramSeries: Se, get LastPriceAnimationMode() { return Pi }, LineSeries: Xs, get LineStyle() { return n }, get LineType() { return i }, get MismatchDirection() { return St }, get PriceLineSource() { return Ti }, get PriceScaleMode() { return oi }, get TickMarkType() { return Di }, get TrackingModeExitMode() { return ki }, createChart: function (t, i) { return Ns(t, new Ki, Ki.Wc(i)) }, createChartEx: Ns, createImageWatermark: function (t, i, n) { return new Ce(t, new Ne(i, n)) }, createOptionsChart: function (t, i) { return Ns(t, new se, i) }, createSeriesMarkers: function (t, i) { const n = new tr(t, new Qe); return i && n.setMarkers(i), n }, createTextWatermark: function (t, i) { return new Ce(t, new Ve(i)) }, createUpDownMarkers: function (t, i = {}) { return new lr(t, new hr(i)) }, createYieldCurveChart: function (t, i) { const n = Ls(t); return new ie(n, i) }, customSeriesDefaultOptions: or, defaultHorzScaleBehavior: function () { return Ki }, isBusinessDay: Ii, isUTCTimestamp: Vi, version: function () { return "5.0.3" } }); window.LightweightCharts = _r }();
